{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"Sources/1.1_基础复习题.html":{"url":"Sources/1.1_基础复习题.html","title":"1.1 基础复习题","keywords":"","body":"基础复习题 JavaScript基础 1. JavaScript 包含: ____, ____, 和 ____. 2. JavaScript 的基本类型有 ____, ____, 和 ____. 3. JavaScript 的复合类型有 ____, ____, ____, ____, ____, ____, 和 ____. 还有两个核心类型: ____ 和 ____. 4. JavaScript 还有两个空类型: ____ 和 ____. 5. JavaScript 中获得类型的运算符是 ____. 使用该运算符返回的结果是什么类型? ____. 6. JavaScript 中 === 和 == 有什么区别? ____. 7. JavaScript 中 in 运算符有什么用? ____. 8. JavaScript 的关系运算符是: ____. 9. JavaScript 的条件运算符是: ____. 10. JavaScript 中创建对象使用 ____ 运算符. 11. 什么是引用类型, 什么是值类型? ____. 12. JavaScript 什么叫逻辑中断: ____. 13. JavaScript 中 delete 运算符的作用是 ____. 14. JavaScript 中循环语句有 ____ 种. 分别是: ____, ____, ____, 和 ____. 15. JavaScript 中分支语句有 ____ 种. 分别是: ____, ____. 16. JavaScript 中跳转语句 break 与 continue 如何使用? ____. 调试工具的使用 1. 需要测试的浏览器有几种: ____, ____, ____, ____, 和 ____. 2. 如何设置断点: ____. 3. 如何查看变量的数据: ____. JavaScript数据类型 JavaScript中的数据类型分为两种：基本数据类型和复杂数据类型。 基本数据类型 number string boolean undefined null 复杂数据类型 object 如何判断一个变量的数据类型 typeof关键字，可以用来返回变量对应的数据类型。 基本类型与转换 1. 数字类型转字符串有 ____ 种方法. 分别是: ____, ____ 和 ____. 2. 判断数据是否为数字的方法: ____. 3. 判断数字是否为有限数字的方法: ____. 4. 字符串转换成数字的方法有 ____ 种方法. 分别是: ____, ____. 5. boolean 类型转换成字符串使用: ____. 6. 数字或字符串转换成 boolean 类型使用: ____, ____, ____, ____. 函数与对象 1. 定义函数的基本语法: ____, ____, 和 ____. 2. 什么是引用类型, 什么是值类型? ____. "},"Sources/1.2.1_Array.html":{"url":"Sources/1.2.1_Array.html","title":"1.2.1 Array","keywords":"","body":"Array对象 Array对象属性 属性 描述 length 设置或返回数组中元素的数目。 Array对象方法 方法 描述 concat() 连接两个或更多的数组，并返回结果。 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 pop() 删除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reverse() 颠倒数组中元素的顺序。 shift() 删除并返回数组的第一个元素 slice() 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 "},"Sources/1.2.2_Date.html":{"url":"Sources/1.2.2_Date.html","title":"1.2.2 Date","keywords":"","body":"Date对象 Data 对象方法 方法 描述 Date() 返回当日的日期和时间 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth () 从 Date 对象返回月份 (0 ~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinute s() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒 (0 ~ 999)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 parse() 返回1970年1月1日午夜到 指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象 中月的某一天 (1 ~ 31)。 setMonth() 设置 Date 对象中月份 ( 0 ~ 11)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setYear() 请使用 setFullYear() 方法代替。 setHours() 设置Date 对象中的小时 (0 ~ 23)。 setMinutes() 设置 Date 对象ä­的分钟 (0 ~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setTime() 以毫秒设置 Date 对象。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换 为字符串。 "},"Sources/1.2.3_Number.html":{"url":"Sources/1.2.3_Number.html","title":"1.2.3 Number","keywords":"","body":"Number对象 Number 对象属性 属性 描述 MAX_VALUE 可表示的最大的数。 MIN_VALUE 可表示的最小的数。 NaN 非数字值。相当于NaN NEGATIVE_INFINITY 负无穷大，溢出时返回该值。相当于-Infinity POSITIVE_INFINITY 正无穷大，溢出时返回该值。相当于Infinity Number 对象方法 方法 描述 toString 把数字转换为字符串，使用指定的基数。 toFixed 把数字转换为字符串，结果的小数点后有指定位数的数字。 toExponential 把对象的值转换为指数计数法。 toPrecision 把数字格式化为指定的长度。 valueOf 返回一个 Number 对象的基本数字值。 "},"Sources/1.2.4_Boolean.html":{"url":"Sources/1.2.4_Boolean.html","title":"1.2.4 Boolean","keywords":"","body":"Boolean对象 Boolean 对象方法 方法 描述 toString() 把逻辑值转换为字符串，并返回结果。 valueOf() 返回 Boolean 对象的原始值。 "},"Sources/1.2.5_String.html":{"url":"Sources/1.2.5_String.html","title":"1.2.5 String","keywords":"","body":"String对象 String 对象属性 属性 描述 length 字符串的长度 String对象方法 方法 描述 anchor() 创建 HTML 锚。 big() 用大号字体显示字符串。 blink() 显示闪动字符串。 bold() 使用粗体显示字符串。 fontcolor() 使用指定的颜色来显示字符串。 fontsize() 使用指定的尺寸来显示字符串。 italics() 使用斜体显示字符串。 link() 将字符串显示为链接。 small() 使用小字号来显示字符串。 strike() 使用删除线来显示字符串。 sub() 把字符串显示为下标。 fixed() 以打字机文本显示字符串。 sup() 把字符串显示为上标。 charAt() 返回在指定位置的字符。 charCodeAt() 返回在指定的位置的字符的 Unicode 编码。 concat() 连接字符串。 fromCharCode() 从字符编码创建一个字符串。 indexOf() 检索字符串。 lastIndexOf() 从后向前搜索字符串。 match() 找到一个或多个正则表达式的匹配。 replace() 替换与正则表达式匹配的子串。 search() 检索与正则表达式相匹配的值。 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分。 split() 把字符串分割为字符串数组。 substr() 从起始索引号提取字符串中指定数目的字符。 substring() 提取字符串中两个指定的索引号之间的字符。 toLocaleLowerCase() 把字符串转换为小写。 toLocaleUpperCase() 把字符串转换为大写。 toLowerCase() 把字符串转换为小写。 toUpperCase() 把字符串转换为大写。 toSource() 代表对象的源代码。 toString() 返回字符串。 valueOf() 返回某个字符串对象的原始值。 "},"Sources/1.2.6_Math.html":{"url":"Sources/1.2.6_Math.html","title":"1.2.6 Math","keywords":"","body":"Math对象 Math对象的属性 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于2.718）。 LN2 返回 2 的自然对数（约等于0.693）。 LN10 返回 10 的自然对数（约等于2.302）。 LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。 LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。 PI 返回圆周率（约等于3.14159）。 SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）。 SQRT2 返回 2 的平方根（约等于 1.414）。 Math对象的方法 属性 描述 abs(x) 返回数的绝对值。 acos(x) 返回数的反余弦值。 asin(x) 返回数的反正弦值。 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 e 的指数。 floor(x) 对数进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y) 返回 x 和 y 中的最高值。 min(x,y) 返回 x 和 y 中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 把数四舍五入为最接近的整数。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 toSource() 返回该对象的源代码。 valueOf() 返回 Math 对象的原始值。 "},"Sources/1.3_值类型和引用类型.html":{"url":"Sources/1.3_值类型和引用类型.html","title":"1.3 值类型和引用类型","keywords":"","body":"值类型和引用类型 1.值类型(基本数据类型) 数值类型 布尔类型 undefined null 字符串 值类型是存储在栈（stack）中的简单数据，也就是说，它们的值直接存储在变量访问的位置。 var num = 10; var str = \"hello JS\"; var flag = true; var un = undefined; var nu = null; 上面定义的这些值类型的数据在内存中的存储如下 2.引用类型(复合数据类型) 对象 数组 函数 存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。 var arr = [1, 2, 3]; var p1 = {name:\"张三\", age:18}; var p2 = { name:\"李四\", age:50, son:{ name:\"李小一\", age:18 } }; var p3 = { name:\"王五\", age:50, children:[ { name:\"王小一\", age:20 }, { name:\"王小二\", age:15 }, { name:\"王小三\", age:12 } ] } 上面定义的这些引用类型的数据在内存中的存储如下 "},"Sources/1.4_值类型和引用类型的特征.html":{"url":"Sources/1.4_值类型和引用类型的特征.html","title":"1.4 值类型和引用类型的特征","keywords":"","body":"值类型和引用类型的特征 1. 值类型和引用类型的赋值 1.1. 值类型赋值，直接将值复制一份 var num1 = 10; var num2 = num1; 上面两句代码，在内存中的体现为： var num1 = 10;表示变量num1存储的是数字10 将数据拷贝一份，也就是将10拷贝一份，这个时候内存中有两个10 将拷贝的10赋值给num2 1.2. 引用类型赋值，是将地址复制一份 var p = {name:\"张三\", age:19}; var p1 = p; 上面两句代码，在内存中的体现为： var p = {name:\"张三\", age:19};,p中存储的是对象的地址 赋值就是将变量p中存储的数据，也就是地址拷贝一份, 然后将该数据赋值给p1 此时内存中只有 1 个对象，变量p和p1同时指向这个对象 问题: 利用p1修改的name属性会影响到p中的name 2. 值类型和引用类型做参数 考虑如下情况：输出结果是多少？ function foo(num){ num++; } var a = 1; foo(a); console.log(a); 继续考虑如下情况：输出结果是多少？ function foo(o){ o.age++; } var p = {name:\"张三\", age:19}; foo(p); console.log(p.age); 总结： 在调用函数的时候，传参的过程其实就是用实参给形参赋值的过程 当参数为值类型的时候，函数内和函数外的两个变量完全不同，仅仅只是存的值一样而已，修改时互不影响 当参数为引用类型的时候，函数内和函数外的两个变量不同，但是共同指向同一个对象，在函数内修改对象数据时会影响外部 扩展： 考虑如下情况：输出结果是多少？ function foo(o){ o = {name:\"张三\", age:18}; } var p; foo(p); console.log(p.age); "},"Sources/1.5_对象的动态特性.html":{"url":"Sources/1.5_对象的动态特性.html","title":"1.5 对象的动态特性","keywords":"","body":"对象的动态特性 1、给对象动态添加属性 当一个对象需要某个属性的时候，可以用两种方式为其添加属性 直接使用对象名.属性名 = 值这种形式，为对象添加对应的属性。 使用关联数组语法对象名[\"属性名\"] = 值这种形式，为对象添加对应的属性 //o是一个没有任何自定义属性的对象 var o = {}; //现在想让他拥有name age gender等属性 //直接使用 对象名.属性名 = 值 o.name = \"张三\"; //使用 对象名[\"属性名\"] = 值 o[\"age\"] = 18; //可以通过打印查看效果 console.log(o.name); console.log(o.age); 注意： 当要动态的为一个对象添加属性的时候，必须使用关联数组的方式。 //接收到了用户的输入 var str = prompt(\"请输入属性名\"); o = {}; //o.str = \"这是一个新属性\"; //这么写是不对的，会给对象新增一个str属性 //正确的写法如下 o[str]=\"这是一个新属性\"; 2、对象属性的访问形式 点语法：对象名.属性名 关联数组：对象名[属性名] var o = { name:\"张三\", sayHello:function(){ console.log(\"你好，我叫\"+ this.name); } }; //点语法 console.log(o.name); //关联数组语法 console.log(o[\"name\"]); //这两种用法同样适用于方法 o.sayHello(); o[\"sayHello\"](); //可以对这个对象的属性进行遍历，如果是值就打印，如果是方法就调用 for(var k in o){ if ( typeof o[ k ] == 'function' ) { o[ k ](); } else { console.log( 'log: ' + o[ k ] ); } } "},"Sources/1.6_DOM操作复习.html":{"url":"Sources/1.6_DOM操作复习.html","title":"1.6 DOM操作复习","keywords":"","body":"常用DOM操作 四字总结：增删查改 获取元素操作 getElementById getElementsByTagName getElementsByClassName 元素节点操作 appendChild insertBefore removeChild replaceChild cloneNode createElement createTextNode（创建文本节点） 属性节点操作 getAttribute setAttribute removeAttribute 常用DOM属性 className innerHTML innerText/textContent value children "},"Sources/1.7_异常处理.html":{"url":"Sources/1.7_异常处理.html","title":"1.7 异常处理","keywords":"","body":"异常处理 常见的异常分类 运行环境的多样性导致的异常（浏览器） 语法错误，代码错误 异常最大的特征，就是一旦代码出现异常，后面的代码就不会再执行 异常捕获 捕获异常，使用try-catch语句 try{ //这里写可能出现异常的代码 }catch(e){ //这里的e就是捕获的异常对象 //可以在这里写，出现异常后的处理代码 } 异常捕获语句执行的过程为： 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中 catch中处理错误信息 然后继续执行后面的代码 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码 通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。 注意： 语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。 try-catch在一般日常开发中基本用不到，但是如果要写框架什么的，用的会非常多。因为这个会让框架变得健壮 抛出异常 如何手动的抛出异常呢？ 案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。 抛出异常使用throw关键字，语法如下： throw 异常对象; 异常对象一般是用new Error(\"异常消息\"), 也可以使用任意对象 function test(para){ if(para == undefined){ throw new Error(\"请传递参数\"); //这里也可以使用自定义的对象 throw {\"id\":1, msg:\"参数未传递\"}; } } try{ test(); }catch(e){ console.log(e); } 异常的传递机制 function f1 () { f2(); // f1 称为调用者, 或主调函数, f2 称为被调用者, 或被调函数 } function f2 () { f3(); } function f3() { throw new Error( 'error' ); } f1(); 当在被调函数内发生异常的时候，异常会一级一级往上抛出。 异常捕获语句的完整模式 异常捕获语句的完整模式为try-catch-finally try { //可能出现错误的代码 } catch ( e ) { //如果出现错误就执行 } finally { //结束 try 这个代码块之前执行, 即最后执行 } finally中的代码，不管有没有发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到 "},"Sources/1.8_调试工具的使用.html":{"url":"Sources/1.8_调试工具的使用.html","title":"1.8 调试工具的使用","keywords":"","body":"调试工具的使用 在程序代码中寻找错误叫做代码调试。调试很难，但幸运的是，很多浏览器都内置了调试工具。 内置的调试工具可以开始或关闭，严重的错误信息会发送给用户。 1.1 调试窗口介绍 1.1.1 开启 windows系统f12、Mac系统command + shift + c 1.1.2 功能 名称 描述 指针 选择页面中的元素 手机 使用移动端界面调试 Elements 元素面板，查看Web页面的HTML与CSS，可以双击元素，对当前页面进行修改 Console 控制台面板，可以作为shell在页面上与JaveScript交互。注意：控制台与该页面是一个整体，在控制台中的任何操作，会影响到页面 Sources 源代码面板，可以设置断点来调试JaveScript Network 网络面板，可以明确的查看到访问Web页面所产生的全部请求（包括应答状态、响应时间、数据量等信息）和下载的资源文件，并可以模拟不同的网络状态（在线、离线、3G等）下对Web的加载情况，可以用于分析和优化网页加载性能 Performance 性能面板，记录和查看Web页面在浏览器中运行时的性能表现（注意是运行时，而不是加载时），主要用于发现Web页面运行时性能瓶颈和性能调优 Memory 内存面板，记录执行JS函数对CPU和内存的使用情况，可以识别开销大的JS函数，跟踪内存泄露，帮助代码优化，提高JS执行性能 Application 应用面板，记录Web页面加载的所有资源信息，包括IndexedDB与Web SQL数据库、本地和会话存储、cookie、应用程序缓存、图像、字体、JS脚本和样式表 Security 安全面板，查看Web页面的安全和认证情况，确保网站上正确地实现了HTTPS Audits 审计面板，从性能（Performance）、PWA兼容性（Progressive Web App）、可访问性（Accessibility）、最佳实践（Best Practices）、搜索引擎优化（SEO）这五个维度给你的网站打分，并给出一份评估报告和优化建议，可以说是非常的强 1.2 console.log调试 可以使用 console.log() 方法在调试窗口上打印 JavaScript 值，来调试 1.3 断点调试 在Source面板中，我们可以设置断点 (代码停止执行的位置)，且可以在代码执行时检测变量。 Source面板：左侧资源区、中部工作区、右侧控制台 1.2.1 设置断点技巧 逐步与逐过程混合 断点加继续运行 条件断点(右键添加 add contitional breakpoint) 1.2.2 debugger关键字 debugger 关键字用于停止执行 JavaScript，并调用调试函数。 这个关键字与在调试工具中设置断点的效果是一样的。 注意：如果没有调试可用，debugger 语句将无法工作。 var x = 15 * 5; debugger; document.getElementbyId(\"demo\").innerHTML = x; // 开启 debugger ，代码在本行前停止执行。 1.2.2 执行控制 逐过程运行，一次运行一个函数 单步运行(逐步运行)，一次运行一句，如果是函数，进入函数体内运行 继续运行，从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束 1.2.4 Watch 利用 watch 监视窗口跟踪监控变量，点击\"+\"号添加变量名，可以查看对象成员 1.2.5 小技巧 工作区左侧行号下方的{}，点击可以格式化调试代码 配置Framework Ignore List：调试器将跳过脚本，并且不会在抛出异常时停止 工作区源码，右键选择Add Script to ignore list 在DevTools的Settings中的Ignore List选项卡中手动设置 "},"Sources/2.1_面向对象概念介绍.html":{"url":"Sources/2.1_面向对象概念介绍.html","title":"2.1 面向对象概念介绍","keywords":"","body":"面向对象的基本概念 1.什么是面向对象编程？ 2.面向过程和面向对象的对比 Example 1：洗衣服 面向过程的思维方式： step 1:收拾脏衣服 step 2:打开洗衣机盖 step 3:将脏衣服放进去 step 4:设定洗衣程序 step 5:开始洗衣服 step 6:打开洗衣机盖子 step 7:晒衣服 面向对象的思维方式： 洗衣机需要什么对象？ 女朋友 洗衣机 在面向对象的思维方式中：我们只关心要完成事情需要的对象。 总结：面向对象是一种解决问题的思路，一种编程思想。 对象是什么呢？ 万物皆对象 JavaScript中的对象是什么？ 在JavaScript中，所谓的对象，就是键值对的集合。 比如要描述一个人，这个人有name,age,gender,体现在代码中： { name:\"张三\", age:18, gender:\"Male\" } 比如要做一个学生管理系统，那学生就是要设计的对象，学生拥有name,age,gender,address,phone,体现在代码中： { name:\"刘亦菲\", age:18, gender:\"female\", address:\"上海\", phone:\"110\" } 3.总结 面向过程关注的实现功能的步骤，是如何把功能拆解后一步步的实现 面向对象则是关注的实现功能的一系列的对象 "},"Sources/2.2_面向对象编程举例.html":{"url":"Sources/2.2_面向对象编程举例.html","title":"2.2 面向对象编程举例","keywords":"","body":"面向对象编程举例 举例1 设置页面中的div和p的边框为1px solid red 传统的处理办法 // 任务需求: // 1> 获取div标签 var divs = document.getElementsByTagName( 'div' ); // 2> 遍历获取到的div标签 for(var i = 0; i 获取到每一个div元素,设置div的样式 divs[i].style.border = \"1px dotted black\"; } // 4> 获取p标签 var ps = document.getElementsByTagName(\"p\"); // 5> 遍历获取到的p标签 for(var j = 0; j 使用函数进行封装优化 // 通过标签名字来获取页面中的元素 function tag(tagName) { // var dvs = document.getElementsByTagName(tagName); // return dvs; return document.getElementsByTagName(tagName); } // 封装一个设置样式的函数 function setStyle(arr) { for(var i = 0; i 使用面向对象的方式 // 更好的做法：是将功能相近的代码放到一起 var itcast = { getEle: { tag: function (tagName) { return document.getElementsByTagName(tagName); }, id: function (idName) { return document.getElementById(idName); } }, setCss: { setStyle: function (arr) { for(var i = 0; i 举例2 创建一个 div 标签, 并设置其样式, 加入页面中 传统的处理办法 //1. 首先找对象 //2. 任何操作应该交给对象完成 // 任务需求: // 1> 创建一个 div 标签 var div = document.createElement( 'div' ); // 2> 将 div 加到页面中 document.body.appendChild( div ); // 3> 设置 div 的样式 div.style.border = '1px dashed red'; div.style.width = '400px'; div.style.height = '300px'; 使用面向对象的方式 // 面向对象的方式去思考: // 1, 抽取对象( 名词提炼法 ): div, body // 2, 分析属性与方法( 动词提炼 ): 加到, 设置样式 var divTag = new DivTag(); // 内部应该创建 dom 对象 // 构造函数内部应该创建 dom 对象 div, 同时将其设置为属性 // 需要一个 div 的构造函数 function DivTag() { this.DOM = document.createElement( 'div' ); this.__加到 = function ( node ) { // 需要将 this.DOM 加到 node 中 node.appendChild( this.DOM ); }; this.__设置样式 = function ( name, value ) { // 设置 this.DOM 的样式 this.DOM.style[ name ] = value; }; } var divTag = new DivTag(); divTag.__设置样式( 'border', '1px solid red' ); divTag.__设置样式( 'width', '400px' ); divTag.__设置样式( 'height', '100px' ); divTag.__设置样式( 'backgroundColor', 'pink' ); "},"Sources/2.3_构造函数.html":{"url":"Sources/2.3_构造函数.html","title":"2.3 构造函数","keywords":"","body":"构造函数的作用 function Person(name, age){ this.name = name; this.age = age; } //断点调试，进行类型查看 var p1 = new Person(); var p2 = new Object(); var p3 = new Date(); var p4 = new RegExp(); var p5 = {}; 1.构造函数是干什么用的？ 在JavaScript中，构造函数是给对象添加属性，初始化属性用的。 2. 对象的创建过程 var p = new Person(); 以上面这个p对象创建为例： 首先使用new关键字创建对象，类似于使用{},这个时候创建出来的对象是一个\"没有任何成员\"的对象。这里需要注意两点： 使用new关键字创建的对象，对象的类型就是创建这个对象使用的构造函数的函数名 使用{}创建对象，对象的类型一定是Object，相当于使用了new Object() 使用构造函数为其初始化成员 在构造函数调用开始的时候，有一个赋值操作，也就是让this = 刚创建出来的对象 在构造函数中，this就代表刚创建出来的对象 在构造函数中，利用对象的动态特性，为对象添加成员 "},"Sources/2.4_面向对象的三大特性.html":{"url":"Sources/2.4_面向对象的三大特性.html","title":"2.4 面向对象的三大特性","keywords":"","body":"面向对象的特性 JavaScript面向对象的特性 1. 封装性 对象是将数据与功能组合到一起, 即封装 js 对象就是 键值对的集合 键值如果是数据( 基本数据, 复合数据, 空数据 ), 就称为属性 如果键值是函数, 那么就称为方法 对象就是将属性与方法封装起来 方法是将过程封装起来 2. 继承性 所谓继承就是自己没有, 别人有,拿过来为自己所用, 并成为自己的东西 2.1. 传统继承基于模板 子类可以使用从父类继承的属性和方法。 class Person { string name; int age; } class Student : Person { } var stu = new Student(); stu.name 即：让某个类型的对象获得另一个类型的对象的属性的方法 2.2. js 继承基于对象 在JavaScript中，继承就是当前对象可以使用其他对象的方法和属性。 js继承实现举例：混入（mix） function mix ( o1, o2 ) { for ( var k in o2 ) { o1[ k ] = o2[ k ]; } } 3. 多态性（基于强类型）只做了解 把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。 动物 animal = new 子类(); // 子类：麻雀、狗、猫、猪、狐狸... 动物 animal = new 狗(); animal.叫(); "},"Sources/2.5.1_传统构造函数存在的问题.html":{"url":"Sources/2.5.1_传统构造函数存在的问题.html","title":"2.5.1 传统构造函数存在的问题","keywords":"","body":"传统构造函数存在的问题 1. 发现问题 现有构造函数如下： function Person(name, age){ this.name = name; this.age = age; this.sayHi = function(){ console.log(\"你好\"); } } 调用该构造函数创建对象，并对比创建出来的对象的sayHi方法： var p = new Person(\"张三\", 18); var p1 = new Person(\"李四\", 19); console.log(p.sayHi == p1.sayHi); //输出结果为false 由于每个对象都是由new Person创建出来的，因此每创建一个对象，函数sayHi都会被重新创建一次，这个时候，每个对象都拥有一个独立的，但是功能完全相同的方法。 功能相同的函数，完全没有必要再内存中存在这么多份。所以就造成了资源浪费。 2. 解决问题 这里最好的办法就是将函数体放在构造函数之外. 在构造函数中只需要引用该函数即可。 function sayHello(){ console.log(\"你好\"); } function Person(name, age){ this.name = name; this.age = age; this.sayHi = sayHello; } //调用该构造函数创建对象，并对比创建出来的对象的sayHi方法 var p = new Person(\"张三\", 18); var p1 = new Person(\"李四\", 19); console.log(p.sayHi == p1.sayHi); //输出结果为true 这样写依然存在问题： 全局变量增多，会增加引入框架命名冲突的风险 代码结构混乱，会变得难以维护 "},"Sources/2.5.2_使用原型解决构造函数问题.html":{"url":"Sources/2.5.2_使用原型解决构造函数问题.html","title":"2.5.2 使用原型解决构造函数问题","keywords":"","body":"使用原型解决构造函数问题 1. 关键点 每一个函数在定义的时候，都会有跟它关联的一个对象被创建出来 每一个由构造函数创建出来的对象，都会默认的和构造函数的神秘对象关联 当使用一个方法进行属性或者方法访问的时候，会先在当前对象内查找该属性和方法 如果当前对象内未找到，就回去跟它关联的神秘对象内进行查找 function Person(name, age){ this.name = name; this.age = age; this.sayHi = function(){ console.log(\"Hello!\"); }; } var p = new Person(\"张三\", 18); p.sayHi(); //当前对象内有这个方法，所以不会去神秘对象内进行查找 var p1 = new Person(\"李四\", 19); p1.sayHello(); //当前对象没没有找到这个方法，所以去神秘对象内进行查找 问题来了，如何访问到这个神秘对象呢？ //可以通过 构造函数.prototype 访问这个神秘对象 console.log(Person.prototype); 当尝试给这个对象新增一个方法之后: Person.prototype.sayHello = function(){ console.log(\"我是神秘对象中的方法\"); }; 使用p,p1都可以访问这个方法： p.sayHello(); p1.sayHello(); 总结： 所有对象共享神秘对象(构造函数.prototype)内的属性和方法。 2. 解决方案 既然所有对象共享神秘对象(构造函数.prototype)内的属性和方法。我们只需要将需要共享的东西，也就是重复占用内存的东西，全部都放到 神秘对象(构造函数.prototype)中，那么所有对象就都可以使用，并且内存里面也只有一份了。 改造构造函数 function Person(name, age){ this.name = name; this.age = age; } Person.prototype.sayHi = function(){ console.log(\"你好\"); }; //测试 var p = new Person(\"张三\", 18); var p1 = new Person(\"李四\", 19); console.log(p.sayHi == p1.sayHi); //输出true 3.常见的错误 3.1. 将属性写在神秘对象（构造函数.prototype）内 function Car(name){ this.name = name; } function Person() {} Person.prototype.name = '张三'; //基本类型的属性影响不大 Person.prototype.car = new Car(\"法拉利\"); //引用类型的属性，会被所有的对象共享 var p = new Person(); 3.2. 赋值的错误 function Person() {} Person.prototype.name = '张三'; var p1 = new Person(); var p2 = new Person(); p1.name = '李四'; console.log( p1.name ); console.log( p2.name ); // 如果是访问数据, 当前对象中如果没有该数据就到构造函数的原型属性中去找 // 如果是写数据, 当对象中有该数据的时候, 就是修改值; 如果对象没有该数据, 那么就添加值 "},"Sources/2.5.3_原型相关概念.html":{"url":"Sources/2.5.3_原型相关概念.html","title":"2.5.3 原型相关概念","keywords":"","body":"原型相关的概念 1. 神秘对象称与构造函数 神秘对象就是构造函数的 \"原型属性\" 简称原型 (构造函数的原型) 2. 神秘对象与构造函数所创建出来的对象 神秘对象针对构造函数创建出来的对象称为 \"原型对象\" 简称原型 (对象的原型） 3. 原型继承 构造函数创建的对象 继承自 构造函数的原型属性 构造函数创建的对象 继承自 该对象的原型对象 原型中的成员, 可以直接被实例对象所使用 实例对象直接 \"含有\" 原型中的成员 因此实例对象 继承自 原型 这样的继承就是 \"原型继承\" "},"Sources/2.5.4_原型的使用.html":{"url":"Sources/2.5.4_原型的使用.html","title":"2.5.4 原型的使用","keywords":"","body":"原型的使用 1. 使用对象的动态特性 function Person () { } Person.prototype.func = function () { console.log( 'something' ); }; var p = new Person(); p.func(); 2. 直接替换原型对象 function Person () { }; Person.prototype = { func: function () { console.log( '22222' ); } }; var p = new Person(); p.func(); 3. 直接替换原型会出现的问题 function Person () { } Person.prototype.func = function () { console.log( 'something' ); }; var p = new Person(); Person.prototype.func = function () { console.log( 'something' ); }; var p1 = new Person(); p.func(); p1.func(); 替换原型之后，在替换前创建出来的对象和替换后创建出来的对象的原型对象不一致 "},"Sources/2.5.5_proto.html":{"url":"Sources/2.5.5_proto.html","title":"2.5.5 __proto__","keywords":"","body":"对象的__proto__属性 1. 标识符命名规则 区分大小写,Name和name是两个不同的变量 标识符可以以下划线_,美元符$或者字母开头，但是不能是数字 标识符可以由下划线_，美元符$，字母，数字组成 2. 神秘对象的访问 构造函数的prototype属性 之前我们访问神秘对象的时候，使用的是原型属性 prototype function Person(){} //通过构造函数的原型属性prototype可以直接访问原型 Person.prototype; 在之前是无法通过构造函数创建出来的对象访问原型的 function Person(){} var p = new Person(); //以前不能直接通过p来访问神秘对象 实例对象的__proto__属性 __proto__属性最早是火狐浏览器引入的，用以通过实例对象来访问原型，这个属性在早期是非标准的属性 有了__proto__属性，就可以通过构造函数创建出来的对象直接访问神秘对象 function Person(){} var p = new Person(); //实例对象的__proto__属性可以方便的访问到原型对象 p.__proto__; //既然使用构造函数的`prototype`和实例对象的`__proto__`属性 //都可以访问原型对象 //就有如下结论 p.__proto__ === Person.prototype; 3. __proto__属性的用途 可以用来访问原型 在实际开发中除非有特殊的需求，不要轻易的使用实例对象的__proto__属性去修改原型的成员， 在调试过程中，可以轻易的查看原型的成员 tips: 早期如何通过实例对象访问原型？ 可以使用实例对象访问构造函数属性constuctor var p = new Person(); p.constructor.prototype; 4. 给实例继承自原型的属性赋值需要注意的问题 function Person(){}; Person.prototype.name = \"周华健\"; var o1 = new Person(); var o2 = new Person(); o1.name = \"李宗盛\"; //这里修改的不是原型对象的name属性，而是给o1自己新增了一个name属性，进行了赋值 //我们可以对比一下o1和o2的name值 console.log(o1.name , o2.name); "},"Sources/2.6_继承的概念及实现方式.html":{"url":"Sources/2.6_继承的概念及实现方式.html","title":"2.6 继承的概念及实现方式","keywords":"","body":"继承 继承的概念 在JavaScript中，继承就是当前对象可以使用其他对象的方法和属性。 var animal = { name:\"Animal\", sex:\"male\", age:5, bark:function(){ console.log(\"Animal bark\"); } }; var dog = {}; //当前有两个对象，一个animal,一个dog //dog没有属性和方法 //但是我们知道，dog属于animal，所以animal的方法和属性，都可以被dog使用 //如何让dog可以使用animal的属性和方法呢？ //通过继承就可以实现 继承的实现方式 在上一节内容中，最终的结论就是可以通过继承来让dog对象可以使用animal对象的属性和方法，那怎么实现继承呢？ 1. 最简单的继承实现 直接遍历父对象的属性，将所有的属性加到当前对象上 var animal = { name:\"Animal\", sex:\"male\", age:5, bark:function(){ console.log(\"Animal bark\"); } }; var dog = {}; for (var k in animal){ dog[k]= animal[k]; } 2. 原型继承 每一个构造函数都有prototype原型属性，通过构造函数创建出来的对象都继承自该原型属性。所以可以通过更改构造函数的原型属性来实现继承。 function Dog(){ this.type = \"yellow Dog\"; } function extend(obj1, obj2){ for (var k in obj2){ obj1[k] = obj2[k]; } }; //使用混入的方式，将属性和方法添加到构造函数的原型属性上，构造函数所创建出来的实例就都有了这些属性和方法。 extend(Dog.prototype, { name:\"\", age:\"\", sex:\"\", bark:function(){} }) //使用面向对象的思想把extend方法重新封装 //extend是扩展的意思，谁要扩展就主动调用extend这个方法 //所以extend应该是对象的方法，那现在我们要扩展的是构造函数的原型对象 //所以给构造函数的原型对象添加一个extend方法 //如下： Dog.prototype.extend = function(obj){ for (var k in obj){ this[k]=obj[k]; } } //调用方式就变成了下面这种形式 Dog.prototype.extend({ name:\"\", age:\"\", sex:\"\", bark:function(){} }); "},"Sources/2.7_原型三角绘制.html":{"url":"Sources/2.7_原型三角绘制.html","title":"2.7 原型三角绘制","keywords":"","body":"原型三角形绘制 请尝试绘制如下三种情况的原型三角形图： 练习一： function Person() { this.name = '张三'; this.sayHello = function () { } } var p = new Person(); 练习二： function Person() { this.name = '张三'; } Person.prototype.sayHello = function () { } var p = new Person(); 练习三： function Person() { this.name = '张三'; } Person.prototype = { sayHello: function () { } }; var p = new Person(); "},"Sources/2.8_属性搜索原则.html":{"url":"Sources/2.8_属性搜索原则.html","title":"2.8 属性搜索原则","keywords":"","body":"属性搜索原则 访问一个对象的成员的时候，首先是在实例中找，没有找到, 就去原型中找, 但是原型中没有怎么办? 原型链 每一个对象都有原型属性，那么对象的原型属性也会有原型属性，所以这样就形成了一个链式结构，我们称之为原型链。 属性搜索原则 所谓的属性搜索原则，也就是属性的查找顺序，在访问对象的成员的时候，会遵循如下的原则: 首先在当前对象中查找，如果找到，停止查找，直接使用，如果没有找到，继续下一步 在该对象的原型中查找，如果找到，停止查找，直接使用，如果没有找到，继续下一步 在该对象的原型的原型中查找，如果找到，停止查找，直接使用，如果没有找到，继续下一步。 继续往上查找，直到查找到Object.prototype还没有, 那么是属性就返回 undefied，是方法，就报错xxx is not a function。 "},"Sources/2.9.1_原型链结构.html":{"url":"Sources/2.9.1_原型链结构.html","title":"2.9.1 原型链结构","keywords":"","body":"原型链结构 凡是对象就有原型, 原型又是对象, 因此凡是给定义一个对象, 那么就可以找到他的原型, 原型还有原型. 那么如此下去, 就构成一个对象的序列. 称该结构为原型链. 使用构造函数创建出对象, 并且没有利用赋值的方式修改原型, 就说该对象保留默认的原型链. 默认原型链结构是什么样子呢? function Person() { } var p = new Person(); // p 具有默认的原型链 默认的原型链结构就是: 当前对象 -> 构造函数.prototype -> Object.prototype -> null 在实现继承的时候, 有时会利用替换原型链结构的方式实现原型继承, 那么原型链结构就会发生改变 function ItcastCollection () { } ItcastCollection.prototype = []; var arr = new ItcastCollection(); // arr -> [] -> Array.prototype -> Object.prototype -> null // var arr = new Array(); 练习： 描述出{}的原型链结构 描述出[]的原型链结构 "},"Sources/2.9.2_原型式继承.html":{"url":"Sources/2.9.2_原型式继承.html","title":"2.9.2 原型式继承","keywords":"","body":"原型式继承 观察：DOM对象的原型链 原型式继承就是利用修改原型链的结构( 增加一个节点, 删除一个节点, 修改节点中的成员 ), 来使得实例对象可以使用整条链中的所有成员. 绘制原型链结构 注意：函数也有__proto__属性，暂时不考虑这个！ 观察如下代码，绘制相应的原型链结构图: function Person(){}; var p = new Person(); 对应的原型链结构图为： 练习： 绘制{}的原型链结构图 绘制[]的原型链结构图 注意： 在 js 中, 所有的对象字面量在解析以后, 就是一个具体的对象了. 那么可以理解为 调用的 对应的构造方法. 例如在代码中写上 {}, 就相当于new Object() 例如代码中有 [], 就相当于new Array() 例如代码中有 /./, 就相当于new RegExp( '.' ) 注意: 在底层理论执行的过程中, 是否有调用构造函数, 不一定. 和浏览器的版本有关. 练习： 绘制如下代码的原型链结构: var o = { appendTo: function ( dom ) { } }; function DivTag() {} DivTag.prototype = o; var div = new DivTag(); "},"Sources/2.10.1_Object.prototype成员介绍.html":{"url":"Sources/2.10.1_Object.prototype成员介绍.html","title":"2.10.1 Object.prototype成员介绍","keywords":"","body":"Object.prototype成员介绍 Object.prototype常用成员 成员 描述 Object.prototype.__proto__ 指向当对象被实例化的时候，用作原型的对象。 Object.prototype.hasOwnProperty() 返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。 Object.prototype.isPrototypeOf() 返回一个布尔值，表示指定的对象是否在本对象的原型链中。 Object.prototype.toString() 返回对象的字符串表示。 Object.prototype.valueOf() 返回指定对象的原始值。 "},"Sources/2.10.2_Function.html":{"url":"Sources/2.10.2_Function.html","title":"2.10.2 Function","keywords":"","body":"函数的构造函数Function 在 js 中 使用Function可以实例化函数对象。也就是说在 js 中函数与普通对象一样, 也是一个对象类型. 函数是 js 中的一等公民. 函数是对象, 就可以使用对象的动态特性 函数是对象, 就有构造函数创建函数 函数是函数, 可以创建其他对象 函数是唯一可以限定变量作用域的结构 要解决的问题 Function 如何使用 Function 与函数的关系 函数的原型链结构 "},"Sources/2.10.2.1_Function的使用.html":{"url":"Sources/2.10.2.1_Function的使用.html","title":"1) Function的使用","keywords":"","body":"Function 的使用 语法: //Function函数所有的参数全都是字符串 //Function函数的作用就是将所有的参数组合起来，变成一个函数 //1、如果只传一个参数，那么这个函数必然是函数体 //2、如果传多个参数，那么最后一个参数表示函数体，前面的参数代表将要创建的函数的参数 //3、如果不传参数，表示创建一个空函数 new Function(arg1, arg2, arg3, ..., argN, body); 创建一个打印一句话的函数 //传统的方式 function foo(){ console.log(\"你好\"); } //使用Function var func = new Function(\"console.log('你好');\"); 这里两种方式创建出来的函数功能是一样的。 创建一个空函数 //传统的方式 function foo(){} //Function var func = new Function(); 创建一个有参数的函数 //传统的方式 function foo(num){ console.log(num); } //Function var func = new Function(){\"num\", \"console.log(num);\"}; 练习: 利用 Function 创建一个函数, 要求传入两个数字, 打印其和 var func = new Function( 'num1', 'num2', 'console.log( num1 + num2 );' ); 利用 Function 创建一个函数, 要求允许函数调用时传入任意个数参数, 并且函数返回这些数字中最大的数字. 利用 Function 创建一个求三个数中最大数的函数. // 传统 function foo ( a, b, c ){ var res = a > b ? a : b; res = res > c ? res : c; return res; } // Function var func = new Function( 'a', 'b', 'c', 'var res = a > b ? a : b;res = res > c ? res : c;return res;' ) "},"Sources/2.10.2.2_参数代码太长的问题.html":{"url":"Sources/2.10.2.2_参数代码太长的问题.html","title":"2) 参数代码太长的问题","keywords":"","body":"解决代码太长的问题 利用+连接字符串 var func = new Function( 'a', 'b', 'c', 'var res = a > b ? a : b;' + 'res = res > c ? res : c;' + 'return res;' ); 利用字符串特性 function foo ( a, b, c ) { var res = a > b ? a : b; res = res > c ? res : c; return res; } var func = new Function( 'a', 'b', 'c', 'return foo( a, b, c );'); ES6 语法（很少有浏览器实现） 使用键盘左上角的` 表示可换行字符串的界定符，之前我们用的是单引号或者双引号来表示一个字符串字面量，在ES6中可以用反引号来表示该字符串可换行。 (最终)利用 DOM 的特性完成该方法 var res = a > b ? a : b; res = res > c ? res : c; return res; var txt = document.getElementbyId(\"code).innerHtml + ' '; var func = new Function('a', 'b', 'c', txt); "},"Sources/2.10.3_静态成员和实例成员.html":{"url":"Sources/2.10.3_静态成员和实例成员.html","title":"2.10.3 静态成员和实例成员","keywords":"","body":"静态成员与实例成员的概念 静态成员和实例成员这两个概念其实也是从面相对象的编程语言中引入的，对应到JavaScript中的理解为： 静态成员 静态成员是指静态属性和静态方法，所谓静态，就是有构造函数提供的。 实例成员 实例成员是值实例属性和实例方法，所谓实例，就是由构造函数创建出来的对象。 举例说明： function Person(){ this.name = \"zs\", this.sayHello = function(){ console.log(\"Hello World\"); } } //下面这个sayHi方法就是构造函数自己的方法，也就是静态方法 Person.sayHi = function(){ console.log(\"I'm a Person\"); } //原型属性属于构造函数，所以原型属性是静态属性 Person.prototype = {}; var p = new Person(); //这里的name是构造函数创建出来的实例对象的属性，所以是实例属性 p.name = \"李四\"; //这里的sayHello也是构造函数创建出来的实例对象的方法，所以是实例方法 p.sayHello(); 提示： 一般工具型方法都有静态成员提供, 一般与实例对象有关的方法由实例成员表示. 工具方法：比如jQuery.Ajax()、jQuery.trim()、jQuery.Each() "},"Sources/2.10.4_arguments对象.html":{"url":"Sources/2.10.4_arguments对象.html","title":"2.10.4 arguments对象","keywords":"","body":"arguments对象 在每一个函数调用的过程中, 函数代码体内有一个默认的对象arguments, 它存储着实际传入的所有参数。 arguments是一个伪数组对象. 它表示在函数调用的过程中传入的所有参数的集合。在函数调用过程中不规定参数的个数与类型, 可以使得函数调用变得非常灵活性。 JavaScript中的函数并没有规定必须如何传参： 定义函数的时候不写参数, 一样可以调用时传递参数 定义的时候写了参数, 调用的时候可以不传参 定义的时候写了一个参数, 调用的时候可以随意的传递多个而参数 在代码设计中, 如果需要函数带有任意个参数的时候, 一般就不带任何参数, 所有的参数利用arguments对象来获取. 一般的函数定义语法, 可以写成: function foo ( /* ... */ ) { } 练习: 利用 Function 创建一个函数, 要求允许函数调用时传入任意个数参数, 并且函数返回这些数字中最大的数字. function foo ( ) { // 所有的参数都在 arguments 中. 将其当做数组使用 // 问题已转换成在有一个数组中求最大值 var args = arguments; var max = args[ 0 ]; for ( var i = 1; i 练习: 利用 Function 写一个函数, 要求传入任意个数字 求和 "},"Sources/2.10.5_深拷贝和浅拷贝.html":{"url":"Sources/2.10.5_深拷贝和浅拷贝.html","title":"2.10.5 深拷贝和浅拷贝","keywords":"","body":"深拷贝和浅拷贝 1. 浅拷贝和深拷贝的概念 1.1. 什么是浅拷贝？ 如果拷贝的时候，只针对当前对象的属性进行拷贝，而不考虑引用类型的属性，那么这个就是浅拷贝 比如下面这个对象： var p = { name:\"张三\", age:18, car:{ name:\"Ferrari\" } }; /* 浅拷贝的代码 */ //经过深拷贝之后，我们得到一个p对象深拷贝的副本 pCopy 浅拷贝之后，内存中的存储情况： 1.2. 什么是深拷贝？ 如果拷贝的时候，将数据所有的引用结构都拷贝一份，拷贝所得的数据在内存中是完全独立的，那么这个就是深拷贝 比如下面这个对象： var p = { name:\"张三\", age:18, car:{ name:\"Ferrari\" } }; /* 深拷贝的代码 */ //经过深拷贝之后，我们得到一个p对象深拷贝的副本 pCopy 深拷贝之后，内存中的存储情况： 2. 浅拷贝和深拷贝的代码实现 浅拷贝代码实现： var p = { name:\"张三\", age:18, car:{ name:\"Ferrari\" } } //对p对象进行浅拷贝 var pCopy = {}; pCopy.name = p.name; pCopy.age = p.age; pCopy.car = p.car; 深拷贝代码实现： var p = { name:\"张三\", age:18, car:{ name:\"Ferrari\" } } var pCopy = {}; pCopy.name = p.name; pCopy.age = p.age; pCopy.car = {}; pCopy.car.name = p.car.name; 3. 浅拷贝和深拷贝代码封装 浅拷贝封装： var p = { name: '张三', age: 19, copy: function () { // 将当前对象拷贝一份 // 1, 创建对象 var temp = {}; // 2, 复制属性. 在 copy 中使用 this 表示当前对象 for ( var k in this ) { temp[ k ] = this[ k ]; } // 3, 返回对象 return temp; } }; var p2 = p.copy(); p.name = '李四'; p.age = 20; p.gender = '女'; var o = {}; o.func = p.copy; o.func(); 深拷贝封装： var car = { name: '法拉利', deepCopy: function() { // 1, 创建一个对象 var temp = {}; // 2, 拷贝属性, 在判断如果是引用类型需要深拷贝 for ( var k in this ) { if ( typeof this[ k ] === 'object' ) { temp[ k ] = this[ k ].deepCopy(); } else { temp[ k ] = this[ k ]; } } // 3, 返回对象 return temp; } }; var p = { name: '张三', car: car, deepCopy: function () { // 1, 创建一个对象 var temp = {}; // 2, 拷贝属性, 在判断如果是引用类型需要深拷贝 for ( var k in this ) { if ( typeof this[ k ] === 'object' ) { temp[ k ] = this[ k ].deepCopy(); } else { temp[ k ] = this[ k ]; } } // 3, 返回对象 return temp; } } 如果可以保证所有的对象中都有copy方法，那么就可以简化了 写一个deepCopy函数, 每一个对象都使用对象.deepCopy = deepCopy使得当前对象具有拷贝的方法, 那么就可以实现深拷贝了 深拷贝最终版本： var deepCopy = function () { // 1, 创建一个对象 var temp = {}; // 2, 拷贝属性, 在判断如果是引用类型需要深拷贝 for ( var k in this ) { if ( typeof this[ k ] === 'object' ) { temp[ k ] = this[ k ].deepCopy(); } else { temp[ k ] = this[ k ]; } // temp[ k ] = this[ k ]; } // 3, 返回对象 return temp; } var car = { name: '法拉利' }; var p = { name: '张三', age: 19, gender: '男', car: car }; // 让所有的对象都有 拷贝的 方法 car.deepCopy = deepCopy; p.deepCopy = deepCopy; var newP = p.deepCopy(); p.name = '李四'; p.age = 20; p.gender = '女'; p.car.name = '兰博基尼'; "},"Sources/3.1_递归.html":{"url":"Sources/3.1_递归.html","title":"3.1 递归","keywords":"","body":"递归 什么是递归 在程序中，所谓的递归，就是函数自己直接或间接的调用自己。调用自己分两种： 直接调用自己 间接调用自己 就递归而言最重要的就是跳出结构，因为跳出了才可以有结果. 化归思想 化归思想：将一个问题由难化易，由繁化简，由复杂化简单的过程称为化归，它是转化和归结的简称。 递归思想就是将一个问题转换为一个已解决的问题来实现 假如有一个函数f, 如果它是递归函数的话, 那么也就是说函数体内的问题还是转换为 f的形式. function f() { ... f( ... ) ... } 例子: 1, 2, 3, 4, 5, ..., 100 求和 首先假定递归函数已经写好, 假设是foo. 即foo(100)就是求1到100的和 寻找递推关系. 就是n与n-1, 或n-2之间的关系:foo( n ) == n + foo( n - 1 ) var res = foo(100); var res = foo(99) + 100; 将递推结构转换为递归体 function foo(n){ return n + foo( n - 1 ); } 上面就是利用了化归思想： 将 求 100 转换为 求 99 将 求 99 转换为 求 98 ... 将求 2 转换为 求 1 求 1 结果就是 1 即: foo( 1 ) 是 1 将临界条件加到递归体中(求1的结果为1) function foo( n ) { if ( n == 1 ) return 1; return n + foo( n - 1 ); } 练习: 求 1, 3, 5, 7, 9, ... 第n项的结果与前n项和. 序号从0开始 先看求第n项 首先假定递归函数已经写好, 假设是fn. 那么第n项就是fn(n) 找递推关系:fn(n) == f(n-1) + 2 递归体 function fn(n) { return fn(n-1) + 2; } 找临界条件 求 n -> n-1 求 n-1 -> n-2 ... 求 1 -> 0 求 第 0 项, 就是 1 加入临界条件 function fn( n ) { if ( n == 0 ) return 1; return fn( n-1 ) + 2; } 再看求前n项和 假设已完成, sum( n ) 就是前 n 项和 找递推关系: 前 n 项和 等于 第 n 项 + 前 n-1 项的和 递归体 function sum( n ) { return fn( n ) + sum( n - 1 ); } 找临界条件 n == 1结果为 1 加入临界条件 function sum( n ) { if (n == 0) return 1; return fn(n) + sum(n - 1); } 练习 2, 4, 6, 8, 10 第 n 项与 前 n 项和 解题方法和上一题一样。 练习 现有数列: 1, 1, 2, 4, 7, 11, 16, … 求 第 n 项, 求前 n 项和. 求第n项 假设已经得到结果 fn, fn( 10 ) 就是第 10 项 找递推关系 0, 1 => fn( 0 ) + 0 = fn( 1 ) 1, 2 => fn( 1 ) + 1 = fn( 2 ) 2, 3 => fn( 2 ) + 2 = fn( 3 ) ... n-1, n => fn( n-1 ) + n - 1 = fn( n ) 递归体也就清楚了 临界条件是 n == 0 => 1 function fn( n ) { if ( n == 0 ) return 1; return fn( n-1 ) + n - 1; } 前n项和 function sum( n ) { if ( n == 0 ) return 1; return sum( n - 1 ) + fn( n ); } 练习 Fibonacci 数列: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … 求其第 n 项. 递推关系:fn(n) == fn(n-1) + fn(n - 2) function fib( n ) { if ( n == 0 || n == 1 ) return 1; return fib( n - 1 ) + fib( n - 2 ); } 练习 阶乘：一个数字的阶乘表示的是从 1 开始 累乘到这个数字. 例如 3! 表示 1 2 3. 5! 就是 1 2 3 4 5. 规定 0 没有阶乘, 阶乘从1开始。 求n的阶乘 function foo ( n ) { if ( n == 1 ) return 1; return foo( n - 1 ) * n; } 练习 求幂 求幂就是求 某一个数 几次方 2*2 2 的 平方, 2 的 2 次方 求 n 的 m 次方 最终要得到一个函数 power( n, m ) n 的 m 次方就是 m 个 n 相乘 即 n 乘以 (m-1) 个 n 相乘 function power ( n, m ) { if ( m == 1 ) return n; return power( n, m - 1 ) * n; } "},"Sources/3.2.1_词法作用域.html":{"url":"Sources/3.2.1_词法作用域.html","title":"3.2.1 词法作用域","keywords":"","body":"作用域 域，表示的是一个范围，作用域，就是作用范围。 作用域说明的是一个变量可以在什么地方被使用，什么地方不能被使用。 块级作用域 JavaScript中没有块级作用域 { var num = 123; { console.log( num ); } } console.log( num ); 上面这段代码在JavaScript中是不会报错的，但是在其他的编程语言中（C#、C、JAVA）会报错。 这是因为，在JavaScript中没有块级作用域，使用{}标记出来的代码块中声明的变量num，是可以被{}外面访问到的。 但是在其他的编程语言中，有块级作用域，那么{}中声明的变量num，是不能在代码块外部访问的，所以报错。 词法作用域 什么是词法作用域？ 词法( 代码 )作用域, 就是代码在编写过程中体现出来的作用范围. 代码一旦写好, 不用执行, 作用范围就已经确定好了. 这个就是所谓词法作用域. 在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析 如果当前作用规则中有名字了, 就不考虑外面的名字 例子1： var num = 123; function foo() { console.log( num ); } foo(); 例子2： if ( false ) { var num = 123; } console.log( num ); // undefiend 例子3： var num = 123; function foo() { var num = 456; function func() { console.log( num ); } func(); } foo(); 练习： var num1 = 123; function foo1() { var num1 = 456; function foo2() { num1 = 789; function foo3 () { console.log( num1 ); } foo3(); } foo2(); } foo1(); console.log( num1 ); 面试题 var num = 123; function func1(){ console.log(num); } function func2(){ var num = 456; func1(); } "},"Sources/3.2.2_变量名提升.html":{"url":"Sources/3.2.2_变量名提升.html","title":"3.2.2 变量名提升","keywords":"","body":"变量名提升 JavaScript是解释型的语言，但是他并不是真的在运行的时候逐句的往下解析执行。 我们来看下面这个例子： func(); function func(){ alert(\"Funciton has been called\"); } 在上面这段代码中，函数func的调用是在其声明之前，如果说JavaScript代码真的是逐句的解析执行，那么在第一句调用的时候就会出错，然而事实并非如此，上面的代码可以正常执行，并且alert出来Function has been called。 所以，可以得出结论，JavaScript并非仅在运行时简简单单的逐句解析执行！ JavaScript 预解析 JavaScript引擎在对JavaScript代码进行解释执行之前，会对JavaScript代码进行预解析，在预解析阶段，会将以关键字var和function开头的语句块提前进行处理。 关键问题是怎么处理呢？ 当变量和函数的声明处在作用域比较靠后的位置的时候，变量和函数的声明会被提升到作用域的开头。 重新来看上面的那段代码 func(); function func(){ alert(\"Funciton has been called\"); } 由于JavaScript的预解析机制，上面的代码就等效于： function func(){ alert(\"Funciton has been called\"); } func(); 看完函数声明的提升，再来看一个变量声明提升的例子： alert(a); var a = 1; 由于JavaScript的预解析机制，上面这段代码，alert出来的值是undefined，如果没有预解析，代码应该会直接报错a is not defined，而不是输出值。 Wait a minute, 不是说要提前的吗？那不是应该alert出来1，为什么是undefined? 那么在这里有必要说一下声明、定义、初始化的区别。其实这几个概念是C系语言的人应该都比较了解的。 行为 说明 声明 告诉编译器/解析器有这个变量存在,这个行为是不分配内存空间的,在JavaScript中，声明一个变量的操作为：var a; 定义 为变量分配内存空间，在C语言中，一般声明就包含了定义，比如：int a;,但是在JavaScript中，var a;这种形式就只是声明了。 初始化 在定义变量之后，系统为变量分配的空间内存储的值是不确定的，所以需要对这个空间进行初始化，以确保程序的安全性和确定性 赋值 赋值就是变量在分配空间之后的某个时间里，对变量的值进行的刷新操作（修改存储空间内的数据) 所以我们说的提升，是声明的提升。 那么再回过头看，上面的代码就等效于： var a; //这里是声明 alert(a);//变量声明之后并未有初始化和赋值操作，所以这里是 undefined a = 1; 复杂点的情况分析 通过上一小节的内容，我们对变量、函数声明提升已经有了一个最基本的理解。那么接下来，我们就来分析一些略复杂的情况。 函数同名 观察下面这段代码: func1(); function func1(){ console.log('This is func1'); } func1(); function func1(){ console.log('This is last func1'); } 输出结果为： This is last func1 This is last func1 原因分析：由于预解析机制，func1的声明会被提升，提升之后的代码为： function func1(){ console.log('This is func1'); } function func1(){ console.log('This is last func1'); } func1(); func1(); 同名的函数，后面的会覆盖前面的，所以两次输出结果都是This is last func1。 变量和函数同名 alert(foo); function foo(){} var foo = 2; 当出现变量声明和函数同名的时候，只会对函数声明进行提升，变量会被忽略。所以上面的代码的输出结果为 function foo(){} 我们还是来把预解析之后的代码展现出来: function foo(){}; alert(foo); foo = 2; 再来看一种 var num = 1; function num () { alert( num ); } num(); 代码执行结果为： Uncaught TypeError: num is not a function 直接上预解析后的代码： function num(){ alert(num); } num = 1; num(); 预解析是分作用域的 声明提升并不是将所有的声明都提升到window对象下面，提升原则是提升到变量运行的环境(作用域)中去。 function showMsg() { var msg = 'This is message'; } alert(msg); // msg未定义 还是直接把预解析之后的代码写出来： function showMsg() { var msg; msg = 'This is message'; } alert(msg); // msg未定义 预解析是分段的 分段，其实就分script标签的 func(); // 输出 AA2; function func(){ console.log('AA1'); } function func(){ console.log('AA2'); } function func(){ console.log('AA3'); } 在上面代码中，第一个script标签中的两个func进行了提升，第二个func覆盖了第一个func，但是第二个script标签中的func并没有覆盖上面的第二个func。所以说预解析是分段的。 tip:但是要注意，分段只是单纯的针对函数，变量并不会分段预解析。 函数表达式并不会被提升 func(); var func = function(){ alert(\"我被提升了\"); }; 这里会直接报错，func is not a function，原因就是函数表达式，并不会被提升。只是简单地当做变量声明进行了处理，如下： var func; func(); func = function(){ alert(\"我被提升了\"); } 条件式函数声明 console.log(typeof func); if(true){ function(){ return 1; } } console.log(typeof func); 上面这段代码，就是所谓的条件式函数声明，这段代码在Gecko引擎中打印\"undefined\"、\"function\"；而在其他浏览器中则打印\"function\"、\"function\"。 原因在于Gecko加入了ECMAScript以外的一个feature：条件式函数声明。 Conditionally created functions Functions can be conditionally declared, that is, a function declaration can be nested within an if statement. Note: Although this kind of function looks like a function declaration, it is actually an expression (or statement), since it is nested within another statement. See differences between function declarations and function expressions. Note中的文字说明，条件式函数声明的处理和函数表达式的处理方式一样，所以条件式函数声明没有声明提升的特性。 "},"Sources/3.2.3_作用域链.html":{"url":"Sources/3.2.3_作用域链.html","title":"3.2.3 作用域链","keywords":"","body":"作用域链 什么是作用域链 只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。 凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。 例如： function f1() { function f2() { } } var num = 456; function f3() { function f4() { } } 绘制作用域链的步骤: 看整个全局是一条链, 即顶级链, 记为 0 级链 看全局作用域中, 有什么成员声明, 就以方格的形式绘制到 0 级练上 再找函数, 只有函数可以限制作用域, 因此从函数中引入新链, 标记为 1 级链 然后在每一个 1 级链中再次往复刚才的行为 变量的访问规则 首先看变量在第几条链上, 在该链上看是否有变量的定义与赋值, 如果有直接使用 如果没有到上一级链上找( n - 1 级链 ), 如果有直接用, 停止继续查找. 如果还没有再次往上刚找... 直到全局链( 0 级 ), 还没有就是 is not defined 注意,同级的链不可混合查找 练习：绘制作用域链 function f1() { var num = 123; function f2() { console.log( num ); } f2(); } var num = 456; f1(); 如何分析代码 在分析代码的时候切记从代码的运行进度上来分析, 如果代码给变量赋值了, 一定要标记到图中 如果代码比较复杂, 可以在图中描述代码的内容, 有事甚至需要将原型图与作用域图合并分析 练习 var num = 123; function f1() { console.log( num ); } function f2() { var num = 456; f1(); } f2(); 练习 var num = 123; function f1() { console.log( num ); } function f2() { num = 456; f1(); } f2(); 补充 声明变量使用`var`, 如果不使用`var`声明的变量就是全局变量( 禁用 ) 因为在任何代码结构中都可以使用该语法. 那么再代码维护的时候会有问题. 所以除非特殊原因不要这么用. 下面的代码的错误 function foo () { var i1 = 1 // 局部 i2 = 2, // 全局 i3 = 3; // 全局 } 此时注意 var arr = []; for ( var i = 0; i "},"Sources/3.3_闭包.html":{"url":"Sources/3.3_闭包.html","title":"3.3 闭包","keywords":"","body":"闭包 闭包的概念 闭包从字面意思理解就是闭合, 包起来. 简单的来说闭包就是,一个具有封闭的对外不公开的, 包裹结构, 或空间. 在JavaScript中函数可以构成闭包. 一般函数是一个代码结构的封闭结构, 即包裹的特性, 同时根据作用域规则, 只允许函数访问外部的数据, 外部无法访问函数内部的数据, 即封闭的对外不公开的特性. 因此说函数可以构成闭包. 闭包要解决什么问题？ 闭包内的数据不允许外界访问 要解决的问题就是间接访问该数据 函数就可以构成闭包, 要解决的问题就是访问到函数内部的数据 我们观察下面的函数foo，在foo内部有一个变量num，能否在函数外部访问到这个变量num呢？ function foo () { var num = 123; return num; } var res = foo(); console.log( res ); // => 123 分析： 在上面的代码中，确实可以访问到num这个函数内部的变量。但是能不能多次访问呢？ 不能，因为每次访问都得重新调用一次foo函数，每次调用都会重新创建一个num = 123，然后返回。 解决思路 函数内的数据不能直接在函数外被访问，是因为作用域的关系，上级作用域不能直接访问下级作用域中的数据。 但是如果反过来，下级作用域可以直接访问上级作用域中的数据。那么如果在函数foo内定义一个函数，那么在这个内部函数中是可以直接访问foo中的num的。 function foo() { var num = Math.random(); function func() { return num; } return func; } var f = foo(); // f可以直接访问num，而且多次访问，访问的也是同一个，并不会返回新的num var res1 = f(); var res2 = f(); 如何获得超过一个数据 函数的返回值只能有一个，那按照上面的方法，我们只能对函数内部的一个数据进行操作。怎么操作函数内的多个数据呢？ 可以使用对象，代码如下： function foo () { var num1 = Math.random(); var num2 = Math.random(); //可以将多个函数包含在一个对象内进行返回，这样就能在函数外部操作当前函数内的多个变量 return { num1: function () { return num1; }, num2: function () { return num2; } } } 如何完成读取一个数据和修改这个数据 前面讲的都是如何去获取函数内部的数据，接下来我们考虑如何修改函数内部的数据。 同样，也是使用内部的函数进行操作。 function foo() { var num = Math.random(); //分别定义get和set函数，使用对象进行返回 return { //get_num负责获取数据 get_num: function() { return num; }, //set_num负责设置数据 set_num: function(value) { num = value; } } } 闭包的基本结构 一般闭包要解决的的问题就是要想办法间接的获得函数内数据的使用权. 那么我们的可以总结出一个基本的使用模型. 写一个函数, 函数内定义一个新函数, 返回新函数, 用新函数获得函数内的数据 写一个函数, 函数内定义一个对象, 对象中绑定多个函数( 方法 ), 返回对象, 利用对象的方法访问函数内的数据 "},"Sources/3.4_函数的四种调用模式.html":{"url":"Sources/3.4_函数的四种调用模式.html","title":"3.4 函数的四种调用模式","keywords":"","body":"函数的调用模式 函数模式 特征:就是一个简单的函数调用，函数名前面没有任何的引导内容 function foo(){} var func = function(){} foo(); func(); (function(){})(); this在函数模式中的含义： this在函数中表示全局对象，在浏览器中是window对象 方法模式 特征: 方法一定是依附于一个对象, 将函数赋值给对象的一个属性, 那么就成为了方法. function f() { this.method = function () {}; } var o = { method: function () {} } this在方法模式调用中的含义:表示函数所依附的这个对象 构造器调用模式 由于构造函数只是给 this 添加成员. 没有做其他事情. 而方法也可以完成这个操作, 就 this 而言, 构造函数与方法没有本质区别. 特征:使用 new 关键字, 来引导构造函数. function Person(){ this.name = \"zhangsan\"; this.age = 19; this.sayHello = function(){ }; } var p = new Person(); 构造函数中发this与方法中一样, 表示对象, 但是构造函数中的对象是刚刚创建出来的对象 关于构造函数中return关键字的补充说明 构造函数中不需要return, 就会默认的return this 如果手动的添加return, 就相当于 return this 如果手动的添加return 基本类型; 无效, 还是保留原来 返回this 如果手动添加return null; 或return undefiend, 无效 如果手动添加return 对象类型; 那么原来创建的this就会被丢掉, 返回的是 return后面的对象 创建对象的模式 工厂方法 // 工厂就是用来生产的, 因此如果函数创建对象并返回, 就称该函数为工厂函数 function createPerson( name, age, gender ) { var o = {}; o.name = name; o.age = age; o.gender = gender; return o; } // document.createElement() 构造方法 function Person(name, age, gender){ this.name = name; this.age = age; this.gender = gender; } var p = new Person(\"zhangsan\", 19, \"男\"); 寄生式创建对象 function Person(name, age, gender){ var o = {}; o.name = name; o.age = age; o.gender = gender; return o; } var p = new Person(\"Jack\", 18, \"male\"); 混合式创建 混合式继承就是讲所有的属性放在构造方法里面，然后讲所有的方法放在原型里面，使用构造方法和原型配合起来创建对象。 上下文调用模式 上下文(Context)，就是函数调用所处的环境。 上下文调用，也就是自定义设置this的含义。 在其他三种调用模式中，函数/方法在调用的时候，this的值都是指定好了的，我们没办法自己进行设置，如果尝试去给this赋值，会报错。 上下文调用的语法 //第一种， apply 函数名.apply(对象, [参数]); //第二种， call 函数名.call(对象, 参数); //上面两种方式的功能一模一样，只是在传递参数的时候有差异。 功能描述： 语法中的函数名表示的就是函数本身，使用函数调用模式的时候，this默认是全局对象 语法中的函数名也可以是方法(如:obj.method)，在使用方法模式调用的时候，this默认是指当前对象 在使用apply和call的时候，默认的this都会失效，this的值由apply和call的第一个参数决定 补充说明 如果函数或方法中没有this的操作, 那么无论什么调用其实都一样. 如果是函数调用foo(), 那么有点像foo.apply( window ). 如果是方法调用o.method(), 那么有点像o.method.apply( o ). 参数问题 call和apply在没有后面的参数的情况下(函数无参数, 方法无参数) 是完全一样的. 如下： function foo() { console.log( this ); } foo.apply( obj ); foo.call( obj ); 第一个参数的使用规则: 如果传入的是一个对象, 那么就相当于设置该函数中的 this 为参数 如果不传入参数, 或传入 null. undefiend 等, 那么相当于 this 默认为 window foo(); foo.apply(); foo.apply( null ); foo.call( undefined ); 如果传入的是基本类型, 那么 this 就是基本类型对应的包装类型的引用 number -> Number boolean -> Boolean string -> String 第二个参数的使用规则 在使用上下文调用的时候, 原函数(方法)可能会带有参数, 那么这个参数在上下文调用中使用第二个( 第 n 个 )参数来表示 function foo( num ) { console.log( num ); } foo.apply( null, [ 123 ] ); // 等价于 foo( 123 ); 上下文调用模式的应用 上下文调用只是能修改this, 但是使用的最多的地方上是函数借用. 1. 将伪数组转换为数组 传统的做法： var a = {}; a[ 0 ] = 'a'; a[ 1 ] = 'b'; a.length = 2; // 使用数组自带的方法 concat // 如果参数中有数组会把参数数组展开 // 语法: arr.concat( 1, 2, 3, [ 4, [ 5 ] ] ); // 特点：不修改原数组 var arr = []; var newArr = arr.concat( a ); 由于a是伪数组, 只是长得像数组. 所以上面的代码不能成功，不能使用concat方法。 但是apply方法有一个特性, 可以将数组或伪数组作为参数。（IE8不支持伪数组操作） foo.apply( obj, 伪数组 ); // IE8 不支持 利用apply方法，可以写出以下 //将伪数组 a 作为 apply 的第二个参数 var newArr = Array.prototype.concat.apply( [], a ) 处理数组转换, 实际上就是将元素一个一个的取出来构成一个新数组, 凡是涉及到该操作的方法理论上都可以。 push方法 //用法: arr.push( 1 ); //将这个元素加到数组中, 并返回所加元素的个数 arr.push( 1, 2, 3 ); //将这三个元素依次加到数组中, 返回所加个数 var a = { length: 0 }; // 伪数组 a[ a.length++ ] = 'abc'; // a[ 0 ] = 'abc'; a.length++; a[ a.length++ ] = 'def'; // 使用一个空数组, 将元素一个个放到数组中即可 var arr = []; arr.push( a ); // 此时不会将元素展开, 而是将这个伪数组作为一个元素加到数组中 // 再次利用 apply 可以展开伪数组的特征 arr.push.apply( arr, a ); // 利用 apply 可以展开伪数组的特性, 这里就相当于 arr.push( a[0], a[1] ) 2. 求数组中的最大值 传统的做法 var max = arr[ 0 ]; for ( var i = 1; i max ) { ... } } 在 js 中的Math对象中提供了很多数学函数Math.max( 1,2,3 ) 还是利用 apply 可以展开数组的特性 var arr = [ 123456,12345,1234,345345,234,5 ]; Math.max.apply( null, arr ); 3.借用构造函数继承 function Person ( name, age, gender ) { this.name = name; this.age = age; this.gender = gender; } // 需要提供一个 Student 的构造函数创建学生对象 // 学生也应该有 name, age, gender, 同时还需要有 course 课程 function Student ( name, age, gender, course ) { Person.call( this, name, age, gender ); this.course = course; } "},"Sources/3.5_函数的重复创建问题.html":{"url":"Sources/3.5_函数的重复创建问题.html","title":"3.5 函数的重复创建问题","keywords":"","body":"对象/函数重复创建问题 1. 发现问题： 首先分析如下代码： var arr = []; for(var i = 0; i 由于每次循环都会使用{}创建一个新的对象，所以输出结果为false。 再分析如下代码： var arr = []; for(var i = 0; i 跟第一段代码相似，每次循环都会创建一个新的函数，所以输出结果为false。 函数的功能就是用来封装一段代码，方便再次调用。同样功能的函数本来只需要创建一份就可以方便到处调用，但是在上面第二段代码中，被创建了多次，这样就造成了资源浪费。 我们期望的是如下图所示的情况： 2. 解决方案 可以对上面第二段代码进行如下改进： //先定义该函数 function printOut(){ console.log(\"Hello JavaScript\"); } var arr = []; for(var i = 0; i 3. 实际应用 在实际开发当中，经常会有给多个元素注册同一个功能的时间处理函数的情况，如下： HTML代码 div1 div2 div3 div4 JavaScript代码 var divs = document.getElementsByTagName(\"div\"); for(var i = 0; i 可以看到，上面用来注册事件代码的方式，会造成同一个功能的函数在内存中创建多个副本出来，这里暂时只有4个div，如果div的数量增加到100个，1000个，10000个，甚至1000000个呢？ 所以需要对上面的代码进行优化，优化的思路就是我们在上面提到的，首先创建一个处理函数，然后在循环中直接使用已经创建好的函数即可，这样内存中就只有一份函数代码存在了。 优化后的JavaScript代码 function divClick(){ this.firstChild.nodeValue = \"我被点击了\"; } var divs = document.getElementsByTagName(\"div\"); for(var i = 0; i "},"Sources/3.6_ES5严格模式.html":{"url":"Sources/3.6_ES5严格模式.html","title":"3.6 ES5严格模式","keywords":"","body":"ES5严格模式 一、概述 除了正常运行模式，ECMAscript 5添加了第二种运行模式：\"严格模式\"（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 设立\"严格模式\"的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 \"严格模式\"体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。越来越向一门真正的开发语言语法进化(JavaScript刚开始设计的时候只是用来做一些小功能，并不是作为一门真正的编程开发语言设计创建的)。向java，oc，swift这种完整语言进化。 另一方面，同样的代码，在\"严格模式\"中，可能会有不一样的运行结果；一些在\"正常模式\"下可以运行的语句，在\"严格模式\"下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 本文将对\"严格模式\"做详细介绍。 二、进入标志 进入\"严格模式\"的标志，是下面这行语句： \"use strict\"; 老版本的浏览器会把它当作一行普通字符串，加以忽略。 三、如何调用 \"严格模式\"有两种调用方法，适用于不同的场合。 3.1 针对整个脚本文件 将\"use strict\"放在脚本文件的第一行，则整个脚本都将以\"严格模式\"运行。如果这行语句不在第一行，则无效，整个脚本以\"正常模式\"运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。 (严格地说，只要前面不是产生实际运行结果的语句，\"use strict\"可以不在第一行，比如直接跟在一个空的分号后面。) 　　　　 \"use strict\"; 　　　　 console.log(\"这是严格模式。\"); 　　 　　　　 console.log(\"这是正常模式。\");kly, it's almost 2 years ago now. I can admit it now - I run it on my school's network that has about 50 computers. 　　 上面的代码表示，一个网页中依次有两段Javascript代码。前一个script标签是严格模式，后一个不是。 3.2 针对单个函数 将\"use strict\"放在函数体的第一行，则整个函数以\"严格模式\"运行。 function strict(){ \"use strict\"; return \"这是严格模式。\"; } function notStrict() { return \"这是正常模式。\"; } 3.3 脚本文件的变通写法 因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。 (function (){ \"use strict\"; // some code here })(); 四、语法和行为改变 4.0 简述 严格模式对Javascript的语法和行为，都做了一些改变。详细讲解之前，先简单列举一下严格模式中的限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 4.1 全局变量显式声明 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 \"use strict\"; v = 1; // 报错，v未声明 for(i = 0; i 因此，严格模式下，变量都必须先用var命令声明，然后再使用。 4.2 静态绑定 Javascript语言的一个特点，就是允许\"动态绑定\"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。 具体来说，涉及以下几个方面。 1) 禁止使用with语句 因为with语句无法在编译时就确定，属性到底归属哪个对象。 \"use strict\"; var v = 1; with (o){ // 语法错误 v = 2; } 2) 创设eval作用域 正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。 正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。 \"use strict\"; var x = 2; console.info(eval(\"var x = 5; x\")); // 5 console.info(x); // 2 4.3 增强的安全措施 1) 禁止this关键字指向全局对象 function f(){ return !this; } // 返回false，因为\"this\"指向全局对象，\"!this\"就是false function f(){ \"use strict\"; return !this; } // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。 因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。 function f(){ \"use strict\"; this.a = 1; }; f();// 报错，this未定义。TypeError:undefined is not an object 2) 禁止在函数内部遍历调用栈 function f1(){ \"use strict\"; f1.caller; // 报错 f1.arguments; // 报错 } f1(); 4.4 禁止删除变量 严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。 \"use strict\"; var x; delete x; // 语法错误 var o = Object.create(null, {'x': { value: 1, configurable: true }}); delete o.x; // 删除成功 4.5 显式报错 正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。 \"use strict\"; var o = {}; Object.defineProperty(o, \"v\", { value: 1, writable: false }); o.v = 2; // 报错 严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。 \"use strict\"; var o = { get v() { return 1; } }; o.v = 2; // 报错 严格模式下，对禁止扩展的对象添加新属性，会报错。 \"use strict\"; var o = {}; Object.preventExtensions(o); o.v = 1; // 报错 严格模式下，删除一个不可删除的属性，会报错。 \"use strict\"; delete Object.prototype; // 报错 4.6 重名错误 严格模式新增了一些语法错误。 1) 对象不能有重名的属性 正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。 \"use strict\"; var o = { p: 1, p: 2 }; // 语法错误 2) 函数不能有重名的参数 正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。 \"use strict\"; function f(a, a, b) { // 语法错误 return ; } //f(1,2,3) 正常模式下，能正常调用。此时函数体中使用a时值为2，即对形参2(第2个参数a)的赋值，会覆盖前面的。 4.7 禁止八进制表示法 正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。 \"use strict\"; var n = 0100; // 语法错误 4.8 arguments对象的限制 arguments是函数的参数对象，严格模式对它的使用做了限制。 1) 不允许对arguments赋值 \"use strict\"; arguments++; // 语法错误 var obj = { set p(arguments) { } }; // 语法错误 try { } catch (arguments) { } // 语法错误 function arguments() { } // 语法错误 var f = new Function(\"arguments\", \"'use strict'; return 17;\"); // 语法错误 2) arguments不再追踪参数的变化 function f(a) { a = 2; return [a, arguments[0]]; } f(1); // 正常模式为[2,2] function f(a) { \"use strict\"; a = 2; return [a, arguments[0]]; } f(1); // 严格模式为[2,1] 3) 禁止使用arguments.callee 这意味着，你无法在匿名函数内部调用自身了。 \"use strict\"; var f = function() { return arguments.callee; }; f(); // 报错 4.9 函数必须声明在顶层 将来Javascript的新版本会引入\"块级作用域\"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。 \"use strict\"; // 不允许在非函数的代码块内声明函数。 if (true) { function f() { } // 语法错误 } for (var i = 0; i 4.10 保留字 为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。 使用这些词作为变量名将会报错Unexpected strict mode reserved word function package(protected) { // 语法错误 \"use strict\"; var implements; // 语法错误 } 此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。 "},"Sources/5.1_ECMAScript 6 简介.html":{"url":"Sources/5.1_ECMAScript 6 简介.html","title":"5.1 ECMAScript 6 简介","keywords":"","body":"什么是ES6？ 又叫es2015，es7是2016 ECMAScript es标准的作用： 定义js的发展方向的一套标准 ECMAScript ES es3 es5 严格模式 es6/es2015/ECMAScript 6.0 变量定义变化let const 块级作用域 解构赋值 字符串、函数、数组的扩展 新的面向对象编程语法 异步 ...... ES6狭义上就是指ES2015，广义上是一个泛指，指5.1版本以后的JavaScript的下一代标准，涵盖了ES2015,ES2016,ES2017等；亦指下一代JavaScript语言。 本书中提到 ES6 的地方，一般是指 ES2015 标准 Bable Bable：Babel是一个JavaScript编译器，它可以将ES6+语法编译为浏览器支持的ES5语法。 TypeScript (也是一个趋势，很火热) TypeScript是 JavaScript 的一个超集，支持 ECMAScript 6 标准。 TypeScript 是由微软开发的自由和开源的编程语言。 TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。 语言特性 TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括： 类型批注和编译时类型检查 类型推断 类型擦除 接口 枚举 Mixin 泛型编程 名字空间 元组 Await 以下功能是从 ECMA 2015 反向移植而来： 类 模块 lambda 函数的箭头语法 可选参数以及默认参数 JavaScript 与 TypeScript 的区别 TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。 TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。 ES5 ⊂ ES6 ⊂ TypeScript "},"Sources/5.2_let和const命令.html":{"url":"Sources/5.2_let和const命令.html","title":"5.2 let和const命令","keywords":"","body":"变量定义变化let/const let ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 不允许重复声明：let不允许在相同作用域内，重复声明同一个变量。 块级作用域：let 声明的变量，只在 let 命令所在的代码块内有效。解决命名冲突问题，能体现代码的封装性 let命令每次定义的作用域都在本次循环的方法体内，即每一次循环的i其实都是一个新的变量。 不存在变量提升：var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 暂时性死区：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 var tmp = 123; if (true) { tmp = 'abc'; // ReferenceError let tmp; } // 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 const const声明一个只读的常量。一旦声明，常量的值就不能改变。 const定义常量时，必须初始化，否则Missing initializer in const declaration 如定义了常量，再去修改就会报错error Assignment to constant variable 不可以给常量赋值 const定义的常量，作用域与let相同 应用场景：const用来定义静态变量，加载模块的时候，定义个常量，把模块赋值给常量 比较 var let const 重复定义 允许 不允许 不允许 作用域 不受块级作用域限制 块级作用域(只在声明所在的块级作用域内有效) 块级作用域 变量提升 是 否 否 值 可以改变 可以改变 不可以改 "},"Sources/5.3_块级作用域.html":{"url":"Sources/5.3_块级作用域.html","title":"5.3 块级作用域","keywords":"","body":"块级作用域 为什么需要块级作用域？ ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 var tmp = new Date(); function f() { console.log(tmp); if (false) { var tmp = 'hello world'; } } f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 var s = 'hello'; for (var i = 0; i 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 块级作用域 凡是被{}包裹的代码属于一个代码块。 ES6 允许块级作用域的任意嵌套。 \\{\\{\\{\\{ { let insane = 'Hello World' } console.log(insane); // 报错 }}}}; 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 // IIFE 写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } 块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。以下代码根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此下面两种情况实际都能运行，不会报错。 // 情况一 if (true) { function f() {} } // 情况二 try { function f() {} } catch(e) { // ... } ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 "},"Sources/5.4_解构赋值.html":{"url":"Sources/5.4_解构赋值.html","title":"5.4 解构赋值","keywords":"","body":"变量的解构赋值 注意：下面使用默认值的场景中，都是只有值严格等于 `undefined` 时才会触发默认值，等于 `null` 不会触发默认值 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 一、数组的解构赋值 1.1 基本用法 以前，为变量赋值，只能直接指定值。 let a = 1; let b = 2; let c = 3; ES6 允许写成下面这样。 let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”(Swift语言特性、C#好像也有)，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 完全解构(如上) 不完全解构。即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 let [x, y] = [1, 2, 3]; x // 1 y // 2 let [a, [b], d] = [1, [2, 3], 4]; a // 1 b // 2 d // 4 解构不成功。变量的值会等于undefined let [x, y, ...z] = ['a']; x // \"a\" y // undefined z // [] let [foo] = []; //foo undefined let [bar, foo] = [1]; //foo undefined 解构报错。如果等号的右边不是数组（或者严格地说，不是可遍历的结构 — 要么转为对象以后不具备 Iterator 接口，要么本身就不具备 Iterator 接口），那么将会报错。 // 报错 let [foo] = 1; let [foo] = false; let [foo] = NaN; let [foo] = undefined; let [foo] = null; // 以上转为对象以后不具备 Iterator 接口 let [foo] = {}; // 以上本身就不具备 Iterator 接口 1.2 默认值 解构赋值允许指定默认值。 let [foo = true] = []; foo // true let [x, y = 'b'] = ['a']; // x='a', y='b' let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意： ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 let [x = 1] = [undefined]; x // 1 let [x = 1] = [null]; x // null 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 function f() { console.log('aaa'); } let [x = f()] = [1]; // 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 let x; if ([1][0] === undefined) { x = f(); } else { x = [1][0]; } 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 let [x = 1, y = x] = []; // x=1; y=1 let [x = 1, y = x] = [2]; // x=2; y=2 let [x = 1, y = x] = [1, 2]; // x=1; y=2 let [x = y, y = 1] = []; // ReferenceError: y is not defined 因为x用y做默认值时，y还没有声明。 二、对象的解构赋值 2.1 基本用法 解构不仅可以用于数组，还可以用于对象。 let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; foo // \"aaa\" bar // \"bbb\" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 如果解构失败，变量的值等于undefined。 如果变量名与属性名不一致，必须写成下面这样。 let { foo: baz } = { foo: 'aaa', bar: 'bbb' }; baz // \"aaa\" let obj = { first: 'hello', last: 'world' }; let { first: f, last: l } = obj; f // 'hello' l // 'world' 前者是匹配的模式，后者才是变量。真正被赋值的是后者-变量，而不是前者-模式。 2.2 默认值 对象的解构也可以指定默认值。 var {x = 3} = {}; x // 3 var {x, y = 5} = {x: 1}; x // 1 y // 5 var {x: y = 3} = {}; y // 3 var {x: y = 3} = {x: 5}; y // 5 var { message: msg = 'Something went wrong' } = {}; msg // \"Something went wrong\" 默认值生效的条件是，对象的属性值严格等于`undefined`。 var {x = 3} = {x: undefined}; x // 3 var {x = 3} = {x: null}; x // null 上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。 2.3 注意点 （1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。 // 错误的写法 let x; {x} = {x: 1}; // SyntaxError: syntax error 上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。 // 正确的写法 let x; ({x} = {x: 1}); 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 （2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 ({} = [true, false]); ({} = 'abc'); ({} = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 （3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 let arr = [1, 2, 3]; let {0 : first, [arr.length - 1] : last} = arr; first // 1 last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。 三、字符串的解构赋值 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 const [a, b, c, d, e] = 'hello'; a // \"h\" b // \"e\" c // \"l\" d // \"l\" e // \"o\" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 let {length : len} = 'hello'; len // 5 四、数值和布尔值的解构赋值 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 let {toString: s} = 123; s === Number.prototype.toString // true let {toString: s} = true; s === Boolean.prototype.toString // true // 上面代码中，数值和布尔值的包装对象都有`toString`属性，因此变量`s`都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 let { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError 五、函数参数的解构赋值 5.1 基本用法 函数的参数也可以使用解构赋值。 function add([x, y]){ return x + y; } add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 5.2 默认值 函数参数的解构也可以使用默认值。 function move({x = 0, y = 0}) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, 0] move({}); // [0, 0] move(); // TypeError: Cannot read property 'x' of undefined // 上面代码中，参数是一个对象，通过对这个对象进行解构，得到变量`x`和`y`的值。如果解构失败，`x`和`y`等于默认值。 上面的代码中，move函数只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数move的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数move调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值（称为函数参数默认值，这里简单说一下），就可以避免这种情况。 参数默认值可以与解构赋值的默认值，结合起来使用： function move({x = 0, y = 0} = {}) { return [x, y]; } move(); // [0, 0] 注意，下面的写法会得到不一样的结果。 function move({x, y} = { x: 0, y: 0 }) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, undefined] move({}); // [undefined, undefined] move(); // [0, 0] // 上面代码是为函数`move`的参数指定默认值，而不是为变量`x`和`y`指定默认值，所以会得到与前一种写法不同的结果。 `undefined`就会触发函数参数的默认值。 六、圆括号问题 解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 6.1 不能使用圆括号的情况 以下三种解构赋值不得使用圆括号。 （1）变量声明语句 // 全部报错 let [(a)] = [1]; let {x: (c)} = {}; let ({x: c}) = {}; let {(x: c)} = {}; let {(x): c} = {}; let { o: ({ p: p }) } = { o: { p: 2 } }; 上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数 函数参数也属于变量声明，因此不能带有圆括号。 // 报错 function f([(z)]) { return z; } // 报错 function f([z,(x)]) { return x; } （3）赋值语句的模式 // 全部报错 ({ p: a }) = { p: 42 }; ([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 // 报错 [({ p: a }), { x: c }] = [{}, {}]; 上面代码将一部分模式放在圆括号之中，导致报错。 6.2 可以使用圆括号的情况 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 [(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 "},"Sources/5.5_字符串的一些扩展.html":{"url":"Sources/5.5_字符串的一些扩展.html","title":"5.5 字符串的扩展","keywords":"","body":"字符串的一些扩展 模板字符串 传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 $('#result').append( 'There are ' + basket.count + ' ' + 'items in your basket, ' + '' + basket.onSale + ' are on sale!' ); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 $('#result').append(` There are ${basket.count} items in your basket, ${basket.onSale} are on sale! `); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。（原理：正则实现） 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 模板字符串是可以嵌套的 如果需要引用模板字符串本身，在需要时执行，可以写成函数。 let func = (name) => `Hello ${name}!`; func('Jack') // \"Hello Jack!\" 上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。 使用： 可以当作普通字符串使用 可以用来定义多行字符串 可以用来变量、字符串拼接。在模板字符串中嵌入变量，将变量名写在${}之中 大括号内部可以放入任意的 JavaScript 表达式、使用对象的属性、调用函数 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。 大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。 标签模板 模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数。 如果模板字符串中没有变量，那么紧跟在后面的模板字符串就是标签/函数的参数。 alert`hello` // 等同于 alert(['hello']) 如果模板字符串中有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 函数的第一个参数是一个数组，该数组的成员是模板字符串中，被${...}分割开的部分 其他参数，依次是模板字符串中各个变量被替换后的值。 let a = 5; let b = 10; tag`Hello ${ a + b } world ${ a * b }`; // 等同于 tag(['Hello ', ' world ', ''], 15, 50); // 3个参数 字符串新增方法 str.includes(str) //是否包含str这个字符串 str.startWith(str) //是否以str开头 str.endWith(str) //是否以str结尾 str.repeat(次数) //循环打印字符串 String.raw`hello world\\n` // 该方法往往用于模板字符串的处理，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。 // 你通常不需要把它看成一个普通函数，你只需要把它放在模板字符串前面就可以了，而不是在它后面加个括号和一堆参数来调用它，引擎会替你去调用它。 "},"Sources/5.6_函数、数组、OOP的扩展.html":{"url":"Sources/5.6_函数、数组、OOP的扩展.html","title":"5.6 函数、数组、OOP的扩展","keywords":"","body":"见源代码注释 "},"Sources/5.7_异步编程.html":{"url":"Sources/5.7_异步编程.html","title":"5.7 异步编程","keywords":"","body":"异步编程 同步：任务之间存在一定的约束关系，在执行过程中，存在一定的前后顺序 异步：可以解释为两(多)者之间在随时间的执行过程中，两者之间没有约束关系，相互独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。 各任务以其相对独立的不可预知的速度向前推进。 异步一般需要通过多进程、多线程来实现。 应用场景：延时任务、耗时任务。 需求：需要监听延时-时间到达、耗时任务完成，在此时做一些操作。 技术方案 技术方案：ES6 诞生以前，异步编程的方法，大概有下面四种。 回调函数：以函数作为参数。这个操作一般称为回调callback。 Callback是\"call back\"两个单字的合体，应该有听过\" Call me back\"的英文。电信公司中的说法大概是有客户打来电话给你，可是你正在电话中，客户会留话说请你等会有空时再\"回电\"给它。在程式开发上，callback的使用情境其实也类似—有空了/时间到了/任务执行完了，回过头来调用的。 事件监听 发布/订阅 ES6 Promise 对象 ES6 Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。 ES8 async+await 所有的技术 — 目标：使 异步任务完成后的 回调 更优雅。可读性更高。以同步的方式去写异步的代码 1. 回调函数 以函数作为参数，将此函数称为回调函数。而接收函数作为参数的函数也称为高阶函数。 缺点：可能造成回调地狱(Callback Hell)(多个任务之间相互依赖，回调函数一层层向下嵌套) 2. ES6 Promise对象 3. ES6 generator 4. ES8 async+await "},"Sources/5.8_发布订阅模式和观察者模式.html":{"url":"Sources/5.8_发布订阅模式和观察者模式.html","title":"5.8 发布订阅模式和观察者模式","keywords":"","body":"发布订阅和观察者模式 发布订阅模式、观察者模式是不一样的。 发布订阅模式 或许你用过 eventemitter、node 的 events、Backbone 的 events 等等，这些都是前端早期，比较流行的数据流通信方式，即订阅发布模式。 从字面意思来看，我们需要首先订阅，发布者发布消息后才会收到发布的消息。不过我们还需要一个中间者来协调，从事件角度来说，这个中间者就是事件中心，协调发布者和订阅者直接的消息通信。 完成订阅发布整个流程需要三个角色： 发布者 事件中心 订阅者 以事件为例，简单流程如下： 发布者->事件中心订阅者 订阅者需要向事件中心订阅指定的事件 -> 发布者向事件中心发布指定事件内容 -> 事件中心通知订阅者 -> 订阅者收到消息（可能是多个订阅者），到此完成了一次订阅发布的流程。 观察者模式 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 观察者模式我们可能比较熟悉的场景就是响应式数据，如 Vue 的响应式、Mbox 的响应式。 观察者模式有完成整个流程需要两个角色： 目标 观察者 简单流程如下： 目标观察者 观察者观察目标（监听目标）-> 目标发生变化-> 目标主动通知观察者 "},"Sources/5.9_前端模块化方案总结.html":{"url":"Sources/5.9_前端模块化方案总结.html","title":"5.9 前端模块化方案总结","keywords":"","body":"一、模块化 1.1 什么是模块化 那么，到底什么是模块化开发呢？ 模块：1、在通信、计算机、数据处理控制系统的电路中，可以组合和更换的硬件单元。2、大型软件系统中的一个具有独立功能的部分。 现实生活中模块化的例子：模块化计算机(cpu、内存、显卡、风扇、硬盘、光驱等等模块)、谷歌模块化手机、模块化房屋 代码模块化例子：日期模块、数学计算模块、日志模块等，所有这些模块共同组成了程序软件系统 模块化： 模块化开发就是将程序划分成一个个(互相依赖的)小文件/模块来开发，然后将小模块组合起来； 这个模块中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构； 这个模块可以将自己希望暴露的变量、函数、对象等导出给其结构使用； 也可以通过某种方式，导入另外模块中的变量、函数、对象等； 模块化的好处： 防止命名冲突 代码复用（非模块化开发时，代码重用时，引入 js 文件的数目可能少了或者引入的顺序不对，会导致一些问题） 高维护性（模块之间有高耦合低内聚的特点） 1.2 JavaScript设计缺陷 无论你多么喜欢JavaScript，以及它现在发展的有多好，我们都需要承认在Brendan Eich用了10天写出JavaScript的时候，它都有很多的缺陷： 比如var定义的变量作用域问题； 比如JavaScript的面向对象并不能像常规面向对象语言一样使用class； 比如JavaScript没有模块化的问题； Brendan Eich本人也多次承认过JavaScript设计之初的缺陷，但是随着JavaScript的发展以及标准化，存在的缺陷问题基本都得到了完善。 JavaScript目前已经得到了快速的发展，无论是web、移动端、小程序端、服务器端、桌面应用都被广泛的使用； 在网页开发的早期，Brendan Eich开发JavaScript仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的： 这个时候我们只需要讲JavaScript代码写到标签中即可； 并没有必要放到多个文件中来编写； 按钮 document.getElementById(\"btn\").onclick = function() { console.log(\"按钮被点击了\"); } 但是随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂了： ajax的出现，前后端开发分离，意味着后端返回数据后，我们需要通过JavaScript进行前端页面的渲染； SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现； 包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤； 所以，模块化已经是JavaScript一个非常迫切的需求。 1.3 没有模块化的JavaScript 1.3.1 技术方案 演变过程： 全局函数 ”污染”了全局变量，无法保证不与其它模块发生变量名冲突 没有模块的划分，只能人为的认为它们属于一个模块，但是程序并不能区分哪些函数是同一个模块 将函数封装到对象命名空间下 从代码级别可以明显的区分出哪些函数属于同一个模块 从某种程度上解决了变量命名冲突的问题，但是并不能从根本上解决命名冲突 会暴露所有的模块成员，内部状态可以被外部改写，不安全 命名空间越来越长 立即函数调用表达式(IIFE，Immediately Invoked Function Expression) 将模块封装为立即执行函数形式，将公有方法，通过在函数内部返回值的形式向外暴露 会有人强调职责单一性，不要与程序的其它部分直接交互。比如当使用到第三方依赖时，通过向匿名函数注入依赖项的形式，来保证模块的独立性，还使模块之间的依赖关系变得明显 var calculator=(function(){ var add=function(v1,v2){ return v1+v2; } return { add:add } })() var calculator=(function(cal,$){ cal.add2=function(){ var v1=$('#v1').val(); var v2= $('#v2').val(); return (v1-0)+(v2-0); } return cal; })(window.calculator||{},window.$) //在这告诉我要jquery //依赖注入 //很牵强的解决文件依赖问题的方法 IIFE也是有很大缺陷的，见下方代码举例 1.3.2 问题举例 我们先来简单体会一下没有模块化代码的问题。 我们知道，对于一个大型的前端项目，通常是多人开发的（即使一个人开发，也会将代码划分到多个文件夹中）： 我们假设有两个人：小明和小丽同时在开发一个项目，并且会将自己的JavaScript代码放在一个单独的js文件中。 // 小明开发了aaa.js文件，代码如下（当然真实代码会复杂的多）： var flag = true; if (flag) { console.log(\"aaa的flag为true\") } // 小丽开发了bbb.js文件，代码如下： var flag = false; if (!flag) { console.log(\"bbb使用了flag为false\"); } 很明显出现了一个问题： 大家都喜欢使用flag来存储一个boolean类型的值； 但是一个人赋值了true，一个人赋值了false； 如果之后都不再使用，那么也没有关系； 但是，小明又开发了ccc.js文件： if (flag) { console.log(\"使用了aaa的flag\"); } 问题来了：小明发现ccc中的flag值不对 对于聪明的你，当然一眼就看出来，是小丽将flag赋值为了false； 但是如果每个文件都有上千甚至更多的代码，而且有上百个文件，你可以一眼看出来flag在哪个地方被修改了吗？ 备注：引用路径如下： 所以，没有模块化对于一个大型项目来说是灾难性的。 1.3.3 IIFE的缺陷 使用IIFE解决上面的问题： // aaa.js const moduleA = (function () { var flag = true; if (flag) { console.log(\"aaa的flag为true\") } return { flag: flag } })(); // bbb.js const moduleB = (function () { var flag = false; if (!flag) { console.log(\"bbb使用了flag为false\"); } })(); // ccc.js const moduleC = (function() { const flag = moduleA.flag; if (flag) { console.log(\"使用了aaa的flag\"); } })(); 命名冲突的问题，有没有解决呢？解决了。 但是，我们其实带来了新的问题： 第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用； 第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写； 第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况； 所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。 我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码； 这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性； 1.4 JavaScript中模块化方案 历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import。直到ES6（2015）才推出了自己的模块化方案，在此之前，社区制定了一些模块加载方案，最主要的有： 先有规范，后有实现： 服务器端规范 CommonJS => NodeJS、 Browserify 浏览器端规范 AMD => RequireJS 浏览器端规范 CMD => SeaJS 二、CommonJS规范 2.1 CommonJS和Node 我们需要知道CommonJS是一个规范，最初提出来是在浏览器意外的地方使用，并且当时被命名为ServerJS，后来为了体现它的广泛性，修改为CommonJS，平时我们也会简称为CJS。 Node是CommonJS在服务器端一个具有代表性的实现； Browserify是CommonJS在浏览器中的一种实现； webpack打包工具具备对CommonJS的支持和转换（后面会讲到）； 所以，Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发： 2.2 Node模块化语法 2.2.1 模块 // bar.js const name = 'coderwhy'; const age = 18; function sayHello(name) { console.log(\"Hello \" + name); } // main.js console.log(name, age); sayHello('kobe'); /* 上面的代码会报错： - 那么，就意味着别的模块main中不能随便访问另外一个模块bar中的内容； - bar需要 导出 自己想要暴露的变量、函数、对象等；main从bar中 导入 自己想要使用的变量、函数、对象等数据之后，才能使用； */ 在node中每一个文件都是一个独立的模块，有自己的作用域。 每个模块(文件)中包括CommonJS规范的核心变量：exports、module、require； module：每个模块内部，都有一个module对象，代表当前模块。module 是一个全局对象，里面保存了模块的信息路径、父子结构信息、曝露出的对象信息。 module.id //带有绝对路径的模块文件名 module.filename //模块的文件名，带有绝对路径 module.loaded //表示模块是否已经完成加载 module.parent //返回一个对象，表示调用该模块的模块。 module.children //返回一个数组，表示该模块要用到的其他模块。 module.exports //模块对外输出的值。 exports和module.exports可以负责对模块中的内容进行导出； require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容； 模块作用域：在一个模块内变量、函数、对象都属于这个模块，对外是封闭的。 module.exports：模块有封装性，需要打破封装性曝露的方法和属性，要挂载到module.exports 举例： // 在 /Users/computer/Desktop/ccc/lib.js 文件中 console.log(module); Module { id: '.', path: '/Users/computer/Desktop/ccc', exports: { name: 'test' }, parent: null, filename: '/Users/computer/Desktop/ccc/main.js', loaded: false, children: [ Module {...} ], paths: [ '/Users/computer/Desktop/ccc/node_modules', '/Users/computer/Desktop/node_modules', '/Users/computer/node_modules', '/Users/node_modules', '/node_modules' ] } 在Node.js中，模块分为两类： 第一类，系统核心模块(原生模块)，node自带。用名称直接可以加载。 fs(file system) 文件操作 http 网络操作 os 提供了与操作系统相关的实用方法和属性 path 路径操作 querystring 查询参数解析 url url解析 Buffer 等等很多，见官方文档 第二类，文件模块，也称自定义模块。用路径加载。 有一种特殊的文件模块 — 包，被管理在node_modules文件夹中的包，也可以直接用名字加载。 2.2.2 exports导出 强调：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出 // bar.js 导出内容 exports.name = name; exports.age = age; exports.sayHello = sayHello; // main.js 导入内容 const bar = require('./bar'); 上面这行代码意味着什么呢？ 意味着main中的bar变量等于exports对象； main中的bar = bar中的exports 所以，我可以编写下面的代码： const bar = require('./bar'); const name = bar.name; const age = bar.age; const sayHello = bar.sayHello; console.log(name); console.log(age); sayHello('kobe'); 模块之间的引用关系： 为了进一步论证，bar和exports是同一个对象： 所以，bar对象是exports对象的浅拷贝； 浅拷贝的本质就是一种引用的赋值而已； 定时器修改对象： 2.2.3 module.exports 但是Node中我们经常导出东西的时候，又是通过module.exports导出的： module.exports和exports有什么关系或者区别呢？ 我们追根溯源，通过维基百科中对CommonJS规范的解析： CommonJS中是没有module.exports的概念的； 但是为了实现模块的导出，Node中使用的是Module的类(提供了一个Module构造函数)，每一个模块都是Module的一个实例，也就是module； 所以在Node中真正用于导出的其实根本不是exports，而是module.exports； 因为module才是导出的真正实现者； 但是，为什么exports也可以导出呢？ 这是因为module对象的exports属性是exports对象的一个引用；相当于在每个模块头部，有这样一行命令：var exports = module.exports; 也就是说 module.exports = exports = main中的bar； 注意：真正导出的模块内容的核心其实是module.exports，只是为了实现CommonJS的规范，刚好module.exports对exports对象有一个引用而已； 那么，如果我的代码这样修改了： 内存中会有怎么样的表现呢？ 结论：和exports对象没有任何关系了，exports你随便玩自己的吧； module.exports我现在导出一个自己的对象，不带着你玩了； 新的对象取代了exports对象的导出，那么就意味着require导入的对象是新的对象； 2.2.4 require 1. require的加载原理 前面已经说过，CommonJS 的一个模块，就是一个脚本文件。 require命令第一次加载模块时，会执行整个模块(脚本文件)中的js代码。然后在内存生成一个对象。 // aaa.js const name = 'coderwhy'; console.log(\"Hello aaa\"); setTimeout(() => { console.log(\"setTimeout\"); }, 1000); // main.js const aaa = require('./aaa'); // aaa.js中的代码在引入时会被运行一次 生成的对象： { id: '...', exports: { ... }, loaded: true, ... } 上面代码就是 Node 内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。 以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。 模块被多次引入时，因为缓存的原因，最终只加载（运行）一次，之后直接返回缓存的值 // main.js const aaa = require('./aaa'); const bbb = require('./bbb'); // aaa.js const ccc = require(\"./ccc\"); // bbb.js const ccc = require(\"./ccc\"); // ccc.js console.log('ccc被加载'); // ccc中的代码只会运行一次。 为什么只会加载运行一次呢？ 这是因为每个模块对象module都有一个属性：loaded。 为false表示还没有加载，为true表示已经加载； 2. require的查找规则 我们现在已经知道，require是一个函数，可以帮助我们引入一个文件（模块）中导入的对象。 那么，require的查找规则是怎么样的呢？ https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together 这里我总结比较常见的查找规则： 导入格式如下：require(X) 情况一：X是一个核心模块，比如path、http。直接返回核心模块，并且停止查找 加载核心模块。传入名字，不需要传入路径。因为Node.js已经将核心模块的文件代码编译到了二进制的可执行文件中了。在加载的过程中，原生的核心模块的优先级是是最高的。 情况二：X是以 ./ 或 ../ 或 /（根目录）开头的 在Linux或者MAc的操作系统中，/表示系统的根路径。在Windows中，/表示当前文件模块所属的根磁盘路径 第一步：将X当做一个文件在对应的目录下查找； 如果有后缀名，按照后缀名的格式查找对应的文件 如果没有后缀名，会按照如下顺序： 直接查找文件X 查找X.js文件：当做JavaScript脚本文件解析 查找X.json文件：以JSON格式解析。 如果是加载json文件模块，最好加上后缀.json，能稍微的提高一点加载的速度。 json文件Node.js也是通过fs读文件的形式读取出来的，然后通过JSON.parse()转换成一个对象 查找X.node文件：以编译后的二进制文件解析。.node文件通常是c/c++写的一些扩展模块 第二步：没有找到对应的文件，将X作为一个目录。查找目录下面的index文件 查找X/index.js文件 查找X/index.json文件 查找X/index.node文件 如果没有找到，那么报错：not found 情况三：直接是一个X（没有路径），并且X不是一个核心模块 比如在/Users/coderwhy/Desktop/Node/TestCode/04_learn_node/05_javascript-module/02_commonjs/main.js中 编写 require('why') 查找顺序：从当前 package 的 node_modules 里面找，找不到就到当前 package 目录上层 node_modules 里面取... 一直找到全局 node_modules 目录。 这样找到的往往是文件夹，所以接下来就是处理一个文件目录作为 Node 模块的情况。如果文件目录下有 package.json，就根据它的 main 字段找到 js 文件。如果没有 package.json，那就默认取文件夹下的 index.js。 由于 webpack browsersify 等模块打包工具是兼容 node 的模块系统的，自然也会进行同样的处理流程。不同的是，它们支持更灵活的配置。比如在 webpack 里面，可以通过 alias 和 external 字段配置，实现对默认 import 逻辑的自定义。 如果上面的路径中都没有找到，那么报错：not found 流程图： Node.js会通过同步阻塞的方式看这个路径是否存在。依次尝试，直到找到为止，如果找不到，报错 优先从缓存加载：common.js规范：载后，再次加载时，去缓存中取module.exports 参考文献 3. require的加载顺序 如果有多个模块的引入，那么加载顺序是什么？ 如果出现下面模块的引用关系，那么加载顺序是什么呢？ 这个其实是一种数据结构：图结构； 图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）； Node采用的是深度优先算法：main -> aaa -> ccc -> ddd -> eee ->bbb 多个模块的引入关系： 2.3 Node的源码解析 Module类 Module.prototype.require函数 Module._load函数 三、ES6 Module 4.1 认识ES6 Module 4.1.1 ES6 Module的优势 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西，导致完全没办法在编译时做“静态优化”。 由于 ES6 模块是编译时加载： 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高 使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ES6 模块还有以下好处。 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 4.1.2 自动启动严格模式 ES6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。 其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 参考链接： 严格模式—MDN 严格模式—阮一峰 4.1.3 浏览器中加载ES6 Module 1. 加载普通js文件 HTML 网页中，浏览器通过标签加载 JavaScript 脚本。 // code //code... 上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此type=\"application/javascript\"可以省略。 默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。 如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载。 下面就是两种异步加载的语法。 上面代码中，标签打开defer或async属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。 defer与async的区别是： defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行； async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。 一句话，defer是“渲染完再执行”，async是“下载完就执行”。 另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。 2. 加载ES6 Module 浏览器内嵌、外链 ES6 模块代码，也使用标签，但是都要加入type=\"module\"属性。 type属性设为module，所以浏览器知道这是一个 ES6 模块。浏览器对于带有type=\"module\"的，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了标签的defer属性。 ，它们会按照在页面出现的顺序依次执行。 --> 标签的async属性也可以打开： 这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。 同样的：一旦使用了此属性，就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。 --> ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。 import utils from \"./utils.js\"; // other code 对于外部的模块脚本（上例是foo.js），有几点需要注意。 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。 模块脚本自动采用严格模式，不管有没有声明use strict。 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。 同一个模块如果加载多次，将只执行一次。 下面是一个示例模块。 import utils from 'https://example.com/js/utils.js'; const x = 1; console.log(x === window.x); //false console.log(this === undefined); // true 利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中。 const isNotModuleScript = this !== undefined; 4.1.4 本地浏览的报错 代码结构如下（个人习惯） ├── index.html ├── main.js └── modules └── foo.js index.html中引入两个js文件作为模块： 如果直接在浏览器中运行代码，会报如下错误： 这个在MDN上面有给出解释： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules 你需要注意本地测试 — 如果你通过本地加载Html 文件 (比如一个 file:// 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。 你需要通过一个服务器来测试。 我这里使用的VSCode，VSCode中有一个插件：Live Server 通过插件运行，可以将我们的代码运行在一个本地服务中； 4.2 ES6 Module的语法 模块功能主要由两个命令构成：export和import： export命令用于规定模块的对外接口 import命令用于输入其他模块提供的功能。 4.2.1 模块与CommonJS模块的区别 1. 相同点 与CommonJS的相同点：一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。 2. 导出的不同 CommonJS通过module.exports导出的是一个对象，是module.exports属性浅拷贝后导出： 该对象只有在脚本运行完才会生成。 导出的是一个对象意味着可以将这个对象的引用在导入模块中赋值给其他变量；但是最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改； // 导出 var counter = 3; var obj = {count: 3} function incCounter() { counter++; obj.count++; } module.exports = { counter: counter, incCounter: incCounter, obj: obj }; // 导入 var mod = require('./lib'); console.log(mod.counter, mod.obj.count); // 3 3 mod.incCounter(); console.log(mod.counter, mod.obj.count); // 3 4 ES Module通过export导出的不是对象，是一个个导出变量/函数/类本身的引用： 说法1： 它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。 换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。(由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错) 所以，import命令叫做“连接” binding 其实更合适。 说法2： export在导出一个变量时，js引擎会解析这个语法，并且创建模块环境记录（module environment record）； 模块环境记录会和变量进行 绑定（binding），并且这个绑定是实时的； 而在导入的地方，我们是可以实时的获取到绑定的最新值的； export和import绑定的过程： 还是举上面的例子。 // lib.js export let counter = 3; export function incCounter() { counter++; } // main.js import { counter, incCounter } from './lib'; console.log(counter); // 3 incCounter(); console.log(counter); // 4 上面代码说明，ES6 模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。 3. 导入的不同 // CommonJS模块 let { stat, exists, readfile } = require('fs'); // 等同于 let _fs = require('fs'); let stat = _fs.stat; let exists = _fs.exists; let readfile = _fs.readfile; 上面代码实质会整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。 // ES6模块 import { stat, exists, readFile } from 'fs'; 上面代码实质只是从fs模块加载 3 个方法，其他方法不加载。 4.2.2 export export关键字将一个模块中的变量、函数、类等导出； 1. export 方式一：分别导出。在语句声明的前面直接加上export关键字： export const name = 'coderwhy'; export const age = 18; export let message = \"my name is why\"; export function sayHello(name) { console.log(\"Hello \" + name); } // export需要指定对外暴露的接口，所以不能直接输出一个值 // export 40; //error 2. export {} 方式二：统一导出。将所有需要导出的标识符，放到export后面的 {}中。它与上一种写法是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些数据。 注意：这里的 {}里面不是ES6的对象字面量的增强写法，{}也不是表示一个对象的； 所以：export {name: name}，是错误的写法； const name = 'coderwhy'; const age = 18; function sayHello(name) { console.log(\"Hello \" + name); } export { name, age, sayHello } 3. export {<> as <>} 方式三：通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字在导出时给标识符起一个别名：export {<> as <>} export { name as fName, age as fAge, sayHello as fSayHello1, sayHello as fSayHello2, // 重命名后，sayHello可以用不同的名字输出两次。 } 4. export导出的是标识符的地址 export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 export var foo = 'bar'; setTimeout(() => foo = 'baz', 500); 上面代码输出变量foo，值为bar，500 毫秒之后变成baz。 这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。 5. export导出同一个实例 function C() { this.sum = 0; } export let c = new C(); 不同的模块中，加载这个模块，得到的都是同一个实例。对c修改，其他模块导入的数据也会改变 6. export书写位置 export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。 function foo() { export default 'bar' // SyntaxError } foo() 7. export书写次数 一个模块中：export 、export {}、export {<> as <>}都是可以出现0-n次的 4.2.3 import import关键字负责从另外一个模块中导入内容。 import语句会执行所加载的模块。如果同一个模块被加载多次，那么模块里的代码只执行一次。 导入内容的方式也有多种： 1. import {} from '' 方式一：选择导入。import {标识符列表} from '模块'； 注意： 大括号里面的变量名，必须与被导入模块对外接口的名称相同。 这里的{}也不是一个对象，里面只是存放导入的标识符列表内容； import { name, age, sayHello } from './modules/foo.js'; console.log(name) console.log(age); sayHello(\"Kobe\"); import { name } from './modules/foo.js'; import { age } from './modules/foo.js'; // 等同于 import { name, age } from './modules/foo.js'; 上面代码中，虽然name和age在两个语句中加载，但是它们对应的是同一个foo.js模块。也就是说，import语句是 Singleton 模式。 1. import ''的含义 import语句会执行所加载的模块，因此可以有下面的写法。 import 'lodash'; 上面代码仅仅执行lodash模块，但是不导入任何值。 同样的，如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 import 'lodash'; import 'lodash'; // 代码加载了两次`lodash`，但是只会执行一次。 2. import {<> as <>} from '' 方式二：导入时给标识符起别名： import {<> as <>} from '' import { name as wName, age as wAge, sayHello as wSayHello } from './modules/foo.js'; 3. import * as <> from '' 方式三：整体导入。将模块功能放到一个模块功能对象(a module object)上，用*指定： import * as <> from '' import * as foo from './modules/foo.js'; console.log(foo.name); console.log(foo.age); foo.sayHello(\"Kobe\"); // foo.n = \"add\"; // Type Error: object is not extensible // foo.f = function () {}; 注意，模块整体加载所在的那个对象，应该是可以静态分析的，所以不允许运行时改变。上面的写法是不允许的。 4. import导入为只读 import { name } from './modules/foo.js'; name = \"mod\"; // Syntax Error : 'name' is read-only; name是只读的。但是，如果name是一个对象，改写其属性是允许的，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。 5. import from后的路径 import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，后缀名不能省略。 如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。 import { myMethod } from 'util'; 上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。 6. import命令的提升 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。 foo(); import { foo } from 'my_module'; 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。 require('core-js/modules/es6.symbol'); require('core-js/modules/es6.promise'); import React from 'React'; 7. import中不能使用表达式和变量 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 // 报错 import { 'f' + 'oo' } from 'my_module'; // 报错 let module = 'my_module'; import { foo } from module; // 报错 if (x === 1) { import { foo } from 'module1'; } else { import { foo } from 'module2'; } 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。 4.2.4 export default 1. 概述 前面我们学习的导出功能都是有名字的导出（named exports）： 在导出export时指定了名字； 在导入import时需要知道具体的名字； 还有一种导出叫做默认导出（default export） 默认导出export时可以不需要指定名字； 在导入时不需要使用 {}，并且可以自己来指定名字； 它也方便我们和现有的CommonJS等规范相互操作； 2. 导出与导入格式 也是可以导出变量、函数、类的。 // 导出格式1 export default function sub(num1, num2) { return num1 - num2; } // 导出格式2：用在非匿名函数前 export default function() {} // 导出格式3：用在函数变量前 function sub() { console.log('sub'); } export default sub; // 函数名`sub`，在模块外部是无效的。加载的时候，视同匿名函数加载。 // 导入格式1：常用及推荐 import sub from './modules/foo.js'; console.log(sub(20, 30)); // 导入格式2 import * as m from './modules/foo.js'; console.log(m.default.sub(20, 30)); // 导入格式3 import {default as m} from './modules/foo.js'; console.log(m.sub(20, 30)); 3. export default的本质 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 // modules.js function add(x, y) { return x * y; } export {add as default}; // 等同于 export default add; // app.js import { default as foo } from 'modules'; // 等同于 import foo from 'modules'; 正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。 // 正确 export var a = 1; // 正确 var a = 1; export default a; // 含义是将变量`a`的值赋给变量`default`。所以，最后一种写法会报错。 // 错误 // export default var a = 1; // 同样地，因为`export default`命令的本质是将后面的值，赋给`default`变量，所以可以直接将一个值写在`export default`之后。 // 正确 export default 42; // 报错 // export 42; // export后面得跟声明，或者{标识符} 4. export default与export 注意：在一个模块中，export default是可以与export同时使用的： export default用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。 export是没有限制的。export 、export {}、export {<> as <>}都是可以出现0-n次的 // 导出 export default function sub(num1, num2) { return num1 - num2; } export var name = \"module1\"; // 导入 在一条`import`语句中，同时输入默认接口和其他接口 import m, {name} from './modules/foo.js'; //m.sub、name import * as m from './modules/foo.js'; // m.default.sub、m.name import {default as m, name} from './modules/foo.js'; // m.sub、name 4.2.5 export和import结合 // bar.js 导出一个sum函数 export const sum = function(num1, num2) { return num1 + num2; } // foo.js做一个中转 // main.js直接从foo中导入 import { sum } from './modules/foo.js'; console.log(sum(20, 30)); 如果从一个模块中导入的内容，我们希望再直接导出出去，这个时候可以使用export和import的结合，写成一行。 // foo.js 导入，但是只是做一个中转 export { sum } from './bar.js'; // 接口改名 export { sum as barSum } from './bar.js'; // 甚至在foo.js中导出时，我们可以变化它的名字 // 整体导入和导出 export * from './bar.js'; // 相当于实现了模块之间的继承。注意，`export *`命令会忽略后面模块的`default`接口。 // 默认接口 export { default } from 'foo'; // 具名接口改为默认接口的写法如下： export { es6 as default } from './someModule'; // 等同于 import { es6 } from './someModule'; export default es6; // 默认接口也可以改名为具名接口： export { default as es6 } from './someModule'; // ES2020 之前，有一种`import`语句，没有对应的复合写法。[ES2020](https://github.com/tc39/proposal-export-ns-from)补上了这个写法。 export * as ns from \"mod\"; // 等同于 import * as ns from \"mod\"; export {ns}; // 需要注意的是，写成一行以后，`sum`实际上并没有被导入当前模块，只是相当于对外转发了这个接口，导致当前模块不能直接使用`sum`。 为什么要这样做呢？ 在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中； 这样方便指定统一的接口规范，也方便阅读； 这个时候，我们就可以使用export和import结合使用； 4.2.6 import() 1. import()的背景 前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行。所以，import和export命令只能在模块的顶层，是不可以在其放到逻辑代码中（比如在if代码块之中，或在函数之中）的。下面的代码会报错： if (true) { import sub from './modules/foo.js'; } 引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。 这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。 const path = './' + fileName; const myModual = require(path); // 上面的语句就是动态加载，`require`到底加载哪一个模块，只有运行时才知道。`import`命令做不到这一点。 ES2020提案 引入import()函数，支持动态加载模块。 import(specifier) 上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。 2. 语法 import()返回一个 Promise 对象。下面是一个例子。 const main = document.querySelector('main'); import(`./section-modules/${someVariable}.js`) .then(module => { // 加载模块成功以后，这个模块会作为一个对象，当作`then`方法的参数. //.then({export1, export2} => { // 可以使用对象解构赋值的语法，获取输出接口。 //.then({default: theDefault} => { // 如果是default，那么需要解构重命名 module.loadPageInto(main); // module.default来使用默认导出 }) .catch(err => { main.textContent = err.message; }); // 如果想同时加载多个模块，可以采用下面的写法。 Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]) .then(([module1, module2, module3]) => { ··· }); // 返回值是Promise对象，所以也可以用在async函数中 async function main() { const myModule = await import('./myModule.js'); const {export1, export2} = await import('./myModule.js'); const [module1, module2, module3] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]); } main(); import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 3. 适用场合 按需加载。 import()可以在需要的时候，再加载某个模块。比如放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。 条件加载 import()可以放在if代码块，根据不同的情况，加载不同的模块。 动态的模块路径 import()允许模块路径动态生成。 import(f()).then(...); // 根据函数`f`的返回结果，加载不同的模块。 4.2.7 应用: 公共头文件 介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。 // constants.js 模块 export const A = 1; export const B = 3; export const C = 4; // test1.js 模块 import * as constants from './constants'; console.log(constants.A); // 1 console.log(constants.B); // 3 // test2.js 模块 import {A, B} from './constants'; console.log(A); // 1 console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。 // constants/db.js export const db = { url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password' }; // constants/user.js export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator']; 然后，将这些文件输出的常量，合并在index.js里面。 // constants/index.js export {db} from './db'; export {users} from './users'; 使用的时候，直接加载index.js就可以了。 // script.js import {db, users} from './constants/index.js'; 4.2.8 与CommonJS模块化的差异 CommonJS 模块输出的是一个值的拷贝(module.exports的浅拷贝)，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译(解析)时加载。 运行时加载意味着是js引擎在 执行js代码的过程中 加载模块；所以require可以与变量、表达式等运行时代码结合使用 编译时（解析）时加载，意味着import不能和运行时相关的内容放在一起使用： 比如from后面的路径需要动态获取； 比如不能将import放到if等语句的代码块中； 所以我们有时候也称ES Module是静态解析的，而不是动态或者运行时解析的； CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。 同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行； 异步的意味着：不会阻塞主线程继续执行； JS引擎在遇到import时会去获取这个js文件的过程是异步的 设置了 type=module 的script标签，相当于加上了 async 属性； 如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行； CommonJS代码： console.log(\"main代码执行\"); const flag = true; if (flag) { // 同步加载foo文件，并且执行一次内部的代码 const foo = require('./foo'); console.log(\"if语句继续执行\"); } ES Module代码： 四、CommonJS模块与ES6模块的混编 4.3 CommonJS模块加载ES6模块 通常情况下，CommonJS不能加载ES Module 因为CommonJS是同步加载的，但是ES Module必须经过静态分析等，无法在这个时候执行JavaScript代码； 但是这个并非绝对的，某些平台在实现的时候可以对代码进行针对性的解析，也可能会支持； 可以使用import()这个方法加载 (async () => { await import('./my-app.mjs'); })(); 上面代码可以在 CommonJS 模块中运行。 require()不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层await命令，导致无法被同步加载。 4.2 ES6模块加载CommonJS模块 多数情况下，ES Module可以加载CommonJS，但是只能整体加载，不能只加载单一的输出项。 ES Module在加载CommonJS时，会将其module.exports导出的内容作为default导出方式来使用； 这个依然需要看具体的实现，比如webpack中是支持的、Node最新的Current（v14.13.1）版本也是支持的； // foo.js const address = 'foo的address'; module.exports = { address } // main.js import foo from './modules/foo.js'; console.log(foo.address); 还有一种变通的加载方法，就是使用 Node.js 内置的module.createRequire()方法。 // cjs.cjs module.exports = 'cjs'; // esm.mjs import { createRequire } from 'module'; const require = createRequire(import.meta.url); const cjs = require('./cjs.cjs'); cjs === 'cjs'; // true 上面代码中，ES6 模块通过module.createRequire()方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。 4.3 使模块同时支持两种模块化导入 一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。 如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如export default obj，使得 CommonJS 可以用import()进行加载。 如果原始模块是 CommonJS 格式，那么可以加一个包装层。 import cjsModule from '../index.js'; export const foo = cjsModule.foo; 上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。 你可以把这个文件的后缀名改为.mjs，或者将它放在一个子目录，再在这个子目录里面放一个单独的package.json文件，指明{ type: \"module\" }。 如果是Node.js中，还有一种做法是在package.json文件的exports字段，指明两种格式模块各自的加载入口。 \"exports\"：{ \"require\": \"./index.js\"， \"import\": \"./esm/wrapper.js\" } 上面代码指定require()和import，加载该模块会自动切换到不一样的入口文件。 五、Node.js中的模块化 5.1 Node中支持 ES6 Module JavaScript 现在常用的有两种模块。 ES6 模块，简称 ESM； CommonJS 模块，简称 CJS。 CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用require()和module.exports，ES6 模块使用import和export。 从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持，需要进行以下操作： 方式一：文件以 .mjs 结尾，表示使用的是ES Module； 方式二：在package.json中配置字段 type: module，一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。 如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成.cjs。 如果没有type字段，或者type字段为commonjs，则.js脚本会被解释成 CommonJS 模块。 在之前的版本（比如v12.19.0）中，也是可以正常运行的，但是会报一个警告： Node.js 遇到 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定\"use strict\"。 总结为一句话： .mjs文件总是以 ES6 模块加载 .cjs文件总是以 CommonJS 模块加载 .js文件的加载取决于package.json里面type字段的设置。 注意，ES6 模块与 CommonJS 模块尽量不要混用。require命令不能加载.mjs文件，会报错，只有import命令才可以加载.mjs文件。反过来，.mjs文件里面也不能使用require命令，必须使用import。 5.2 Node.js包模块的入口文件设置 5.2.1 package.json 的 main 字段 package.json文件有两个字段可以指定模块的入口文件：main和exports。比较简单的模块，可以只使用main字段，指定模块加载的入口文件。 举例：指定入口文件，格式为ESM // ./node_modules/es-module-package/package.json { \"type\": \"module\", \"main\": \"./src/index.js\" } 上面代码指定项目的入口脚本为./src/index.js，它的格式为 ES6 模块。如果没有type字段，index.js就会被解释为 CommonJS 模块。 然后，import命令就可以加载这个模块。 // ./my-app.mjs import { something } from 'es-module-package'; // 实际加载的是 ./node_modules/es-module-package/src/index.js 上面代码中，运行该脚本以后，Node.js 就会到./node_modules目录下面，寻找es-module-package模块，然后根据该模块package.json的main字段去执行入口文件。 这时，如果用 CommonJS 模块的require()命令去加载es-module-package模块会报错，因为 CommonJS 模块不能处理export命令。 5.2.2 package.json 的 exports 字段 exports字段的优先级高于main字段。它有多种用法。 1. 给脚本或子目录起别名 package.json文件的exports字段可以指定脚本或子目录的别名。 // ./node_modules/es-module-package/package.json { \"exports\": { \"./submodule\": \"./src/submodule.js\", //给脚本文件 src/submodule.js 起别名 \"./features/\": \"./src/features/\"，// 给子目录 ./src/features/ 起别名 } } 通过别名加载： import submodule from 'es-module-package/submodule'; // 加载 ./node_modules/es-module-package/src/submodule.js import feature from 'es-module-package/features/x.js'; // 加载 ./node_modules/es-module-package/src/features/x.js 如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。 // 报错 import submodule from 'es-module-package/private-module.js'; // 不报错 import submodule from './node_modules/es-module-package/private-module.js'; 2. main 的别名. exports字段的别名如果是. 就代表了是模块的主入口，优先级高于main字段，并且可以直接简写成exports字段的值。 { \"exports\": { \".\": \"./main.js\" } } // 等同于 { \"exports\": \"./main.js\" } 由于exports字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。 { \"main\": \"./main-legacy.cjs\", \"exports\": { \".\": \"./main-modern.cjs\" } } 上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是main-legacy.cjs，新版本的 Node.js 的入口文件是main-modern.cjs。 3. 条件加载 利用.这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开--experimental-conditional-exports标志。 { \"type\": \"module\", \"exports\": { \".\": { \"require\": \"./main.cjs\", // 别名`.`的`require`条件指定`require()`命令的入口文件（即 CommonJS 的入口） \"default\": \"./main.js\" // 别名`.`的`default`条件指定其他情况的入口（即 ES6 的入口）。 } } } 上面的写法可以简写如下 { \"exports\": { \"require\": \"./main.cjs\", \"default\": \"./main.js\" } } 注意，如果同时还有其他别名，就不能采用简写，否则或报错。 { // 报错 \"exports\": { \"./feature\": \"./lib/feature.js\", \"require\": \"./main.cjs\", \"default\": \"./main.js\" } } 5.3 Node.js原生模块完全支持ES6 Module Node.js 的内置模块可以整体加载，也可以加载指定的输出项。 // 整体加载 import EventEmitter from 'events'; const e = new EventEmitter(); // 加载指定的输出项 import { readFile } from 'fs'; readFile('./foo.txt', (err, source) => { if (err) { console.error(err); } else { console.log(source); } }); 5.4 加载路径 ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。import命令和package.json文件的main字段如果省略脚本的后缀名，会报错。 // ES6 模块中将报错 import { something } from './index'; 为了与浏览器的import加载规则相同，Node.js 的.mjs文件支持 URL 路径。 import './foo.mjs?query=1'; // 加载 ./foo 传入参数 ?query=1 上面代码中，脚本路径带有参数?query=1，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。 目前，Node.js 的import命令只支持加载本地模块（file:协议）和data:协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以/或//开头的路径）。 5.5 内部变量 ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。 首先，就是this关键字。ES6 模块之中，顶层的this指向undefined；CommonJS 模块的顶层this指向当前模块，这是两者的一个重大差异。 其次，以下这些顶层变量在 ES6 模块之中都是不存在的。 arguments require module exports __filename __dirname 六、循环加载 “循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。 // a.js var b = require('b'); // b.js var a = require('a'); 通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。 但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。 对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。 6.1 CommonJS 模块的循环加载 CommonJS 模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出。 让我们来看，Node 官方文档里面的例子。 // a.js exports.done = false; // 先输出一个`done`变量 var b = require('./b.js'); // 然后加载另一个脚本文件b.js。注意，此时代码就停在这里，等待`b.js`执行完毕，再往下执行。 console.log('在 a.js 之中，b.done = %j', b.done); // b.js执行完毕，返回来a.js接着往下执行，直到执行完毕。 exports.done = true; console.log('a.js 执行完毕'); // b.js exports.done = false; /* 执行到这一行，会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。 此时：a.js已经执行的部分，只有一行：exports.done = false; 即对于b.js来说，它从a.js只输入一个变量done=false 。 */ var a = require('./a.js'); console.log('在 b.js 之中，a.done = %j', a.done); exports.done = true; console.log('b.js 执行完毕'); // b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。 我们写一个脚本main.js，验证这个过程。 var a = require('./a.js'); var b = require('./b.js'); console.log('在 main.js 之中, a.done=%j, b.done=%j', a.done, b.done); 执行main.js，运行结果如下： $ node main.js 在 b.js 之中，a.done = false b.js 执行完毕 在 a.js 之中，b.done = true a.js 执行完毕 在 main.js 之中, a.done=true, b.done=true 上面的代码证明了两件事： 在b.js之中，a.js没有执行完毕，只执行了第一行。 main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行exports.done = true; 总之，CommonJS 输入的是被输出值的拷贝，不是引用。 另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。 var a = require('a'); // 安全的写法 var foo = require('a').foo; // 危险的写法 exports.good = function (arg) { return a.foo('good', arg); // 使用的是 a.foo 的最新值 }; exports.bad = function (arg) { return foo('bad', arg); // 使用的是一个部分加载时的值 }; 上面代码中，如果发生循环加载，require('a').foo的值很可能后面会被改写，改用require('a')会更保险一点。 6.2 ES6 模块的循环加载 ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 请看下面这个例子。 // a.mjs import {bar} from './b'; console.log('a.mjs'); console.log(bar); export let foo = 'foo'; // b.mjs import {foo} from './a'; console.log('b.mjs'); console.log(foo); export let bar = 'bar'; 上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。 $ node --experimental-modules a.mjs b.mjs ReferenceError: foo is not defined 上面代码中，执行a.mjs以后会报错，foo变量未定义，这是为什么？ 让我们一行行来看，ES6 循环加载是怎么处理的： 首先，执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。 接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。 执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。 解决这个问题的方法，就是让b.mjs运行的时候，foo已经有定义了。这可以通过将foo写成函数来解决。 // a.mjs import {bar} from './b'; console.log('a.mjs'); console.log(bar()); function foo() { return 'foo' } // const foo = () => 'foo'; 仍然会执行报错。函数表达式，就不具有提升作用 export {foo}; // b.mjs import {foo} from './a'; console.log('b.mjs'); console.log(foo()); function bar() { return 'bar' } export {bar}; 这时再执行a.mjs就可以得到预期结果。 $ node --experimental-modules a.mjs b.mjs foo a.mjs bar 这是因为函数具有提升作用，在执行import {bar} from './b'时，函数foo就已经有定义了，所以b.mjs加载的时候不会报错。 这也意味着，如果把函数foo改写成函数表达式，也会报错。 6.3 代码示例 我们再来看 ES6 模块加载器SystemJS给出的一个例子。 // even.js import { odd } from './odd' export var counter = 0; export function even(n) { counter++; return n === 0 || odd(n - 1); } // odd.js import { even } from './even'; export function odd(n) { return n !== 0 && even(n - 1); } 上面代码中，even.js里面的函数even有一个参数n，只要不等于 0，就会减去 1，传入加载的odd()。odd.js也会做类似操作。 运行上面这段代码，结果如下。 $ babel-node > import * as m from './even.js'; > m.even(10); true > m.counter 6 > m.even(20) true > m.counter 17 上面代码中，参数n从 10 变为 0 的过程中，even()一共会执行 6 次，所以变量counter等于 6。第二次调用even()时，参数n从 20 变为 0，even()一共会执行 11 次，加上前面的 6 次，所以变量counter等于 17。 这个例子要是改写成 CommonJS，就根本无法执行，会报错。 // even.js var odd = require('./odd'); var counter = 0; exports.counter = counter; exports.even = function (n) { counter++; return n == 0 || odd(n - 1); } // odd.js var even = require('./even').even; module.exports = function (n) { return n != 0 && even(n - 1); } 上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于undefined，等到后面调用even(n - 1)就会报错。 $ node > var m = require('./even'); > m.even(10) TypeError: even is not a function 七、了解：AMD和CMD规范 7.1. CommonJS规范缺点 CommonJS加载模块是同步的： 同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行； 这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快； 如果将它应用于浏览器呢？ 浏览器加载js文件需要先从服务器将文件下载下来，之后在加载运行； 那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作； 所以在浏览器中，我们通常不使用CommonJS规范： 当然在webpack中使用CommonJS是另外一回事； 因为它会将我们的代码转成浏览器可以直接执行的代码； 在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD： 但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换； AMD和CMD已经使用非常少了，所以这里我们进行简单的演练； 7.2. AMD规范 7.2.1 AMD与Require.js AMD主要是应用于浏览器的一种模块化规范： AMD是Asynchronous Module Definition（异步模块定义）的缩写； 它采用的是异步加载模块； 事实上AMD的规范还要早于CommonJS，但是CommonJS目前依然在被使用，而AMD使用的较少了； 我们提到过，规范只是定义代码的应该如何去编写，只有有了具体的实现才能被应用： AMD实现的比较常用的库是require.js和curl.js； 7.2.2 Require.js的使用 第一步：下载require.js 下载地址：https://github.com/requirejs/requirejs 找到其中的require.js文件； 第二步：定义HTML的script标签引入require.js和定义入口文件： data-main属性的作用是在加载完src的文件后会加载执行该文件 第三步：编写如下目录和代码(个人习惯) ├── index.html ├── index.js ├── lib │ └── require.js └── modules ├── bar.js └── foo.js index.js (function() { require.config({ baseUrl: '', paths: { foo: './modules/foo', bar: './modules/bar' } }) // 开始加载执行foo模块的代码 require(['foo'], function(foo) { }) })(); modules/bar.js 如果一个模块不依赖其他，那么直接使用define(function)即可 define(function() { const name = \"coderwhy\"; const age = 18; const sayHello = function(name) { console.log(\"Hello \" + name); } return { name, age, sayHello } }) modules/foo.js define(['bar'], function(bar) { console.log(bar.name); console.log(bar.age); bar.sayHello('kobe'); }) 7.3 CMD规范 7.3.1 CMD与SeaJS CMD规范也是应用于浏览器的一种模块化规范： CMD 是Common Module Definition（通用模块定义）的缩写； 它也采用了异步加载模块，但是它将CommonJS的优点吸收了过来； 但是目前CMD使用也非常少了； CMD也有自己比较优秀的实现方案： SeaJS 7.3.2 SeaJS的使用 1. 下载SeaJS 下载地址：https://github.com/seajs/seajs 找到dist文件夹下的sea.js 2. 引入sea.js和启动模块 seajs是指定主入口文件的，也称为启动模块 seajs.use('./index.js'); /* 通过 seajs.use() 函数可以启动模块 - ('模块id' [,callback]) 加载一个模块，并执行回调函数 - (['模块1', '模块2'] [,callback]) 加载多个模块，并执行回调函数 - callback 参数是可选的。格式为：function( 模块对象 ){ 业务代码 }; - seajs.use 理论上只用于加载启动，不应该出现在 define 中的模块代码里 - seajs.use 和 DOM ready 事件没有任何关系。要想保证 文档结构加载完毕再执行你的 js 代码，一定要在seajs.use内部通过 window.onload 或者 $(function(){}) */ 3. 编写如下目录和代码(个人习惯) ├── index.html ├── index.js ├── lib │ └── sea.js └── modules ├── bar.js └── foo.js 4. 定义模块define 在CMD规范中，一个模块就是一个js文件 module是一个对象，存储了模块的元信息，具体如下： module.id——模块的ID。 module.dependencies——一个数组，存储了此模块依赖的所有模块的ID列表。 module.exports——与exports指向同一个对象。 module.uri define 是一个全局函数，用来定义模块：define( factory ) 对象{}：这种方式，外部会直接获取到该对象 字符串\"\"： 同上 函数：define(function(require, exports, module){ 模块代码 }); 为了减少出错，定义函数的时候直接把这三个参数写上 5. 导出接口exports和module.exports 功能：通过给 exports或module.exports动态的挂载变量、函数或对象，外部会获取到该接口 exports 等价于 module.exports。exports能做什么，module.exports就能做什么 可以通过多次给exports 挂载属性向外暴露 不能直接给 exports 赋值 如果想暴露单个变量、函数或对象可以通过直接给 module.exports 赋值 即可 6. 依赖模块require /* 模块标识/模块id - 模块标识就是一个`字符串`，用来`标识模块` - 模块标识 可以不包含后缀名.js - 以 ./或 ../ 开头的相对路径模块，相对于 require 所在模块的路径 - 不以 ./ 或 ../ 开头的顶级标识，会相对于模块的基础路径解析（配置项中的base） - 绝对路径如http://127.0.0.1:8080/js/a.js、/js/a.js */ requeire('模块id') /* 1.用于根据一个模块id加载/依赖该模块 2.参数必须是一个字符串 3.该方法会得到 要加载的模块中的 module.exports 对象 */ 只能在模块环境define中使用，define(factory)的构造方法第一个参数必须命名为 require 不要重命名require函数或者在任何作用域中给 require 重新赋值 在一个模块系统中，require 加载过的模块会被缓存 默认 require 是同步加载模块的 require.async SeaJS会在html页面打开时通过静态分析一次性记载所有需要的js文件，如果想要某个js文件在用到时才下载，可以使用require.async： require.async('/path/to/module/file', function(m) { //code of callback... }); 这样只有在用到这个模块时，对应的js文件才会被下载，也就实现了JavaScript代码的按需加载。 SeaJS高级配置 alias：别名配置 paths：路径配置 vars：变量配置 map：映射配置 preload：预加载项 debug：调试模式 base：基础路径 charset：文件编码 代码示例 index.js define(function(require, exports, module) { const foo = require('./modules/foo'); }) bar.js define(function(require, exports, module) { const name = 'lilei'; const age = 20; const sayHello = function(name) { console.log(\"你好 \" + name); } module.exports = { name, age, sayHello } }) foo.js define(function(require, exports, module) { const bar = require('./bar'); console.log(bar.name); console.log(bar.age); bar.sayHello(\"韩梅梅\"); }) 八、参考链接 Module的语法和加载实现 — 阮一峰 彻底掌握前端模块化 — codewhy "}}