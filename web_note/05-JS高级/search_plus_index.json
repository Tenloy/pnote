{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"Sources/1.1_基础复习题.html":{"url":"Sources/1.1_基础复习题.html","title":"1.1 基础复习题","keywords":"","body":"基础复习题 JavaScript基础 1. JavaScript 包含: ____, ____, 和 ____. 2. JavaScript 的基本类型有 ____, ____, 和 ____. 3. JavaScript 的复合类型有 ____, ____, ____, ____, ____, ____, 和 ____. 还有两个核心类型: ____ 和 ____. 4. JavaScript 还有两个空类型: ____ 和 ____. 5. JavaScript 中获得类型的运算符是 ____. 使用该运算符返回的结果是什么类型? ____. 6. JavaScript 中 === 和 == 有什么区别? ____. 7. JavaScript 中 in 运算符有什么用? ____. 8. JavaScript 的关系运算符是: ____. 9. JavaScript 的条件运算符是: ____. 10. JavaScript 中创建对象使用 ____ 运算符. 11. 什么是引用类型, 什么是值类型? ____. 12. JavaScript 什么叫逻辑中断: ____. 13. JavaScript 中 delete 运算符的作用是 ____. 14. JavaScript 中循环语句有 ____ 种. 分别是: ____, ____, ____, 和 ____. 15. JavaScript 中分支语句有 ____ 种. 分别是: ____, ____. 16. JavaScript 中跳转语句 break 与 continue 如何使用? ____. 调试工具的使用 1. 需要测试的浏览器有几种: ____, ____, ____, ____, 和 ____. 2. 如何设置断点: ____. 3. 如何查看变量的数据: ____. JavaScript数据类型 JavaScript中的数据类型分为两种：基本数据类型和复杂数据类型。 基本数据类型 number string boolean undefined null 复杂数据类型 object 如何判断一个变量的数据类型 typeof关键字，可以用来返回变量对应的数据类型。 基本类型与转换 1. 数字类型转字符串有 ____ 种方法. 分别是: ____, ____ 和 ____. 2. 判断数据是否为数字的方法: ____. 3. 判断数字是否为有限数字的方法: ____. 4. 字符串转换成数字的方法有 ____ 种方法. 分别是: ____, ____. 5. boolean 类型转换成字符串使用: ____. 6. 数字或字符串转换成 boolean 类型使用: ____, ____, ____, ____. 函数与对象 1. 定义函数的基本语法: ____, ____, 和 ____. 2. 什么是引用类型, 什么是值类型? ____. "},"Sources/1.2.1_Array.html":{"url":"Sources/1.2.1_Array.html","title":"1.2.1 Array","keywords":"","body":"Array对象 Array对象属性 属性 描述 length 设置或返回数组中元素的数目。 Array对象方法 方法 描述 concat() 连接两个或更多的数组，并返回结果。 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 pop() 删除并返回数组的最后一个元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reverse() 颠倒数组中元素的顺序。 shift() 删除并返回数组的第一个元素 slice() 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 "},"Sources/1.2.2_Date.html":{"url":"Sources/1.2.2_Date.html","title":"1.2.2 Date","keywords":"","body":"Date对象 Data 对象方法 方法 描述 Date() 返回当日的日期和时间 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth () 从 Date 对象返回月份 (0 ~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinute s() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒 (0 ~ 999)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 parse() 返回1970年1月1日午夜到 指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象 中月的某一天 (1 ~ 31)。 setMonth() 设置 Date 对象中月份 ( 0 ~ 11)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setYear() 请使用 setFullYear() 方法代替。 setHours() 设置Date 对象中的小时 (0 ~ 23)。 setMinutes() 设置 Date 对象ä­的分钟 (0 ~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 setTime() 以毫秒设置 Date 对象。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换 为字符串。 "},"Sources/1.2.3_Number.html":{"url":"Sources/1.2.3_Number.html","title":"1.2.3 Number","keywords":"","body":"Number对象 Number 对象属性 属性 描述 MAX_VALUE 可表示的最大的数。 MIN_VALUE 可表示的最小的数。 NaN 非数字值。相当于NaN NEGATIVE_INFINITY 负无穷大，溢出时返回该值。相当于-Infinity POSITIVE_INFINITY 正无穷大，溢出时返回该值。相当于Infinity Number 对象方法 方法 描述 toString 把数字转换为字符串，使用指定的基数。 toFixed 把数字转换为字符串，结果的小数点后有指定位数的数字。 toExponential 把对象的值转换为指数计数法。 toPrecision 把数字格式化为指定的长度。 valueOf 返回一个 Number 对象的基本数字值。 "},"Sources/1.2.4_Boolean.html":{"url":"Sources/1.2.4_Boolean.html","title":"1.2.4 Boolean","keywords":"","body":"Boolean对象 Boolean 对象方法 方法 描述 toString() 把逻辑值转换为字符串，并返回结果。 valueOf() 返回 Boolean 对象的原始值。 "},"Sources/1.2.5_String.html":{"url":"Sources/1.2.5_String.html","title":"1.2.5 String","keywords":"","body":"String对象 String 对象属性 属性 描述 length 字符串的长度 String对象方法 方法 描述 anchor() 创建 HTML 锚。 big() 用大号字体显示字符串。 blink() 显示闪动字符串。 bold() 使用粗体显示字符串。 fontcolor() 使用指定的颜色来显示字符串。 fontsize() 使用指定的尺寸来显示字符串。 italics() 使用斜体显示字符串。 link() 将字符串显示为链接。 small() 使用小字号来显示字符串。 strike() 使用删除线来显示字符串。 sub() 把字符串显示为下标。 fixed() 以打字机文本显示字符串。 sup() 把字符串显示为上标。 charAt() 返回在指定位置的字符。 charCodeAt() 返回在指定的位置的字符的 Unicode 编码。 concat() 连接字符串。 fromCharCode() 从字符编码创建一个字符串。 indexOf() 检索字符串。 lastIndexOf() 从后向前搜索字符串。 match() 找到一个或多个正则表达式的匹配。 replace() 替换与正则表达式匹配的子串。 search() 检索与正则表达式相匹配的值。 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分。 split() 把字符串分割为字符串数组。 substr() 从起始索引号提取字符串中指定数目的字符。 substring() 提取字符串中两个指定的索引号之间的字符。 toLocaleLowerCase() 把字符串转换为小写。 toLocaleUpperCase() 把字符串转换为大写。 toLowerCase() 把字符串转换为小写。 toUpperCase() 把字符串转换为大写。 toSource() 代表对象的源代码。 toString() 返回字符串。 valueOf() 返回某个字符串对象的原始值。 "},"Sources/1.2.6_Math.html":{"url":"Sources/1.2.6_Math.html","title":"1.2.6 Math","keywords":"","body":"Math对象 Math对象的属性 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于2.718）。 LN2 返回 2 的自然对数（约等于0.693）。 LN10 返回 10 的自然对数（约等于2.302）。 LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。 LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。 PI 返回圆周率（约等于3.14159）。 SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）。 SQRT2 返回 2 的平方根（约等于 1.414）。 Math对象的方法 属性 描述 abs(x) 返回数的绝对值。 acos(x) 返回数的反余弦值。 asin(x) 返回数的反正弦值。 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 e 的指数。 floor(x) 对数进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y) 返回 x 和 y 中的最高值。 min(x,y) 返回 x 和 y 中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 把数四舍五入为最接近的整数。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 toSource() 返回该对象的源代码。 valueOf() 返回 Math 对象的原始值。 "},"Sources/1.3_值类型和引用类型.html":{"url":"Sources/1.3_值类型和引用类型.html","title":"1.3 值类型和引用类型","keywords":"","body":"值类型和引用类型 1.值类型(基本数据类型) 数值类型 布尔类型 undefined null 字符串 值类型是存储在栈（stack）中的简单数据，也就是说，它们的值直接存储在变量访问的位置。 var num = 10; var str = \"hello JS\"; var flag = true; var un = undefined; var nu = null; 上面定义的这些值类型的数据在内存中的存储如下 2.引用类型(复合数据类型) 对象 数组 函数 存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。 var arr = [1, 2, 3]; var p1 = {name:\"张三\", age:18}; var p2 = { name:\"李四\", age:50, son:{ name:\"李小一\", age:18 } }; var p3 = { name:\"王五\", age:50, children:[ { name:\"王小一\", age:20 }, { name:\"王小二\", age:15 }, { name:\"王小三\", age:12 } ] } 上面定义的这些引用类型的数据在内存中的存储如下 "},"Sources/1.4_值类型和引用类型的特征.html":{"url":"Sources/1.4_值类型和引用类型的特征.html","title":"1.4 值类型和引用类型的特征","keywords":"","body":"值类型和引用类型的特征 1. 值类型和引用类型的赋值 1.1. 值类型赋值，直接将值复制一份 var num1 = 10; var num2 = num1; 上面两句代码，在内存中的体现为： var num1 = 10;表示变量num1存储的是数字10 将数据拷贝一份，也就是将10拷贝一份，这个时候内存中有两个10 将拷贝的10赋值给num2 1.2. 引用类型赋值，是将地址复制一份 var p = {name:\"张三\", age:19}; var p1 = p; 上面两句代码，在内存中的体现为： var p = {name:\"张三\", age:19};,p中存储的是对象的地址 赋值就是将变量p中存储的数据，也就是地址拷贝一份, 然后将该数据赋值给p1 此时内存中只有 1 个对象，变量p和p1同时指向这个对象 问题: 利用p1修改的name属性会影响到p中的name 2. 值类型和引用类型做参数 考虑如下情况：输出结果是多少？ function foo(num){ num++; } var a = 1; foo(a); console.log(a); 继续考虑如下情况：输出结果是多少？ function foo(o){ o.age++; } var p = {name:\"张三\", age:19}; foo(p); console.log(p.age); 总结： 在调用函数的时候，传参的过程其实就是用实参给形参赋值的过程 当参数为值类型的时候，函数内和函数外的两个变量完全不同，仅仅只是存的值一样而已，修改时互不影响 当参数为引用类型的时候，函数内和函数外的两个变量不同，但是共同指向同一个对象，在函数内修改对象数据时会影响外部 扩展： 考虑如下情况：输出结果是多少？ function foo(o){ o = {name:\"张三\", age:18}; } var p; foo(p); console.log(p.age); "},"Sources/1.5_对象的动态特性.html":{"url":"Sources/1.5_对象的动态特性.html","title":"1.5 对象的动态特性","keywords":"","body":"对象的动态特性 1、给对象动态添加属性 当一个对象需要某个属性的时候，可以用两种方式为其添加属性 直接使用对象名.属性名 = 值这种形式，为对象添加对应的属性。 使用关联数组语法对象名[\"属性名\"] = 值这种形式，为对象添加对应的属性 //o是一个没有任何自定义属性的对象 var o = {}; //现在想让他拥有name age gender等属性 //直接使用 对象名.属性名 = 值 o.name = \"张三\"; //使用 对象名[\"属性名\"] = 值 o[\"age\"] = 18; //可以通过打印查看效果 console.log(o.name); console.log(o.age); 注意： 当要动态的为一个对象添加属性的时候，必须使用关联数组的方式。 //接收到了用户的输入 var str = prompt(\"请输入属性名\"); o = {}; //o.str = \"这是一个新属性\"; //这么写是不对的，会给对象新增一个str属性 //正确的写法如下 o[str]=\"这是一个新属性\"; 2、对象属性的访问形式 点语法：对象名.属性名 关联数组：对象名[属性名] var o = { name:\"张三\", sayHello:function(){ console.log(\"你好，我叫\"+ this.name); } }; //点语法 console.log(o.name); //关联数组语法 console.log(o[\"name\"]); //这两种用法同样适用于方法 o.sayHello(); o[\"sayHello\"](); //可以对这个对象的属性进行遍历，如果是值就打印，如果是方法就调用 for(var k in o){ if ( typeof o[ k ] == 'function' ) { o[ k ](); } else { console.log( 'log: ' + o[ k ] ); } } "},"Sources/1.6_DOM操作复习.html":{"url":"Sources/1.6_DOM操作复习.html","title":"1.6 DOM操作复习","keywords":"","body":"常用DOM操作 四字总结：增删查改 获取元素操作 getElementById getElementsByTagName getElementsByClassName 元素节点操作 appendChild insertBefore removeChild replaceChild cloneNode createElement createTextNode（创建文本节点） 属性节点操作 getAttribute setAttribute removeAttribute 常用DOM属性 className innerHTML innerText/textContent value children "},"Sources/1.7_异常处理.html":{"url":"Sources/1.7_异常处理.html","title":"1.7 异常处理","keywords":"","body":"异常处理 常见的异常分类 运行环境的多样性导致的异常（浏览器） 语法错误，代码错误 异常最大的特征，就是一旦代码出现异常，后面的代码就不会再执行 异常捕获 捕获异常，使用try-catch语句 try{ //这里写可能出现异常的代码 }catch(e){ //这里的e就是捕获的异常对象 //可以在这里写，出现异常后的处理代码 } 异常捕获语句执行的过程为： 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中 catch中处理错误信息 然后继续执行后面的代码 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码 通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。 注意： 语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。 try-catch在一般日常开发中基本用不到，但是如果要写框架什么的，用的会非常多。因为这个会让框架变得健壮 抛出异常 如何手动的抛出异常呢？ 案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。 抛出异常使用throw关键字，语法如下： throw 异常对象; 异常对象一般是用new Error(\"异常消息\"), 也可以使用任意对象 function test(para){ if(para == undefined){ throw new Error(\"请传递参数\"); //这里也可以使用自定义的对象 throw {\"id\":1, msg:\"参数未传递\"}; } } try{ test(); }catch(e){ console.log(e); } 异常的传递机制 function f1 () { f2(); // f1 称为调用者, 或主调函数, f2 称为被调用者, 或被调函数 } function f2 () { f3(); } function f3() { throw new Error( 'error' ); } f1(); 当在被调函数内发生异常的时候，异常会一级一级往上抛出。 异常捕获语句的完整模式 异常捕获语句的完整模式为try-catch-finally try { //可能出现错误的代码 } catch ( e ) { //如果出现错误就执行 } finally { //结束 try 这个代码块之前执行, 即最后执行 } finally中的代码，不管有没有发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到 "},"Sources/1.8_调试工具的使用.html":{"url":"Sources/1.8_调试工具的使用.html","title":"1.8 调试工具的使用","keywords":"","body":"调试工具的使用 开启调试窗口 windows 平台: f12 调试窗口介绍 指针: 选择页面中的元素 手机: 使用移动端界面调试 Elements: 查看页面 DOM 树 Console: 控制台(注意, 控制台与该页面是一个整体, 在控制台中的任何操作, 会影响到页面) Source: 代码调试 调试工具的使用 逐过程运行, 一次运行一个函数 单步运行(逐步运行), 一次运行一句, 如果是函数, 进入函数体内运行 继续运行. 从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束 设置断点技巧 逐步与逐过程混合 断点加继续运行 条件断点(右键添加 add contitional breakpoint) 利用 watch 监视窗口可以查看对象成员 "},"Sources/2.1_面向对象概念介绍.html":{"url":"Sources/2.1_面向对象概念介绍.html","title":"2.1 面向对象概念介绍","keywords":"","body":"面向对象的基本概念 1.什么是面向对象编程？ 2.面向过程和面向对象的对比 Example 1：洗衣服 面向过程的思维方式： step 1:收拾脏衣服 step 2:打开洗衣机盖 step 3:将脏衣服放进去 step 4:设定洗衣程序 step 5:开始洗衣服 step 6:打开洗衣机盖子 step 7:晒衣服 面向对象的思维方式： 洗衣机需要什么对象？ 女朋友 洗衣机 在面向对象的思维方式中：我们只关心要完成事情需要的对象。 总结：面向对象是一种解决问题的思路，一种编程思想。 对象是什么呢？ 万物皆对象 JavaScript中的对象是什么？ 在JavaScript中，所谓的对象，就是键值对的集合。 比如要描述一个人，这个人有name,age,gender,体现在代码中： { name:\"张三\", age:18, gender:\"Male\" } 比如要做一个学生管理系统，那学生就是要设计的对象，学生拥有name,age,gender,address,phone,体现在代码中： { name:\"刘亦菲\", age:18, gender:\"female\", address:\"上海\", phone:\"110\" } 3.总结 面向过程关注的实现功能的步骤，是如何把功能拆解后一步步的实现 面向对象则是关注的实现功能的一系列的对象 "},"Sources/2.2_面向对象编程举例.html":{"url":"Sources/2.2_面向对象编程举例.html","title":"2.2 面向对象编程举例","keywords":"","body":"面向对象编程举例 举例1 设置页面中的div和p的边框为1px solid red 传统的处理办法 // 任务需求: // 1> 获取div标签 var divs = document.getElementsByTagName( 'div' ); // 2> 遍历获取到的div标签 for(var i = 0; i 获取到每一个div元素,设置div的样式 divs[i].style.border = \"1px dotted black\"; } // 4> 获取p标签 var ps = document.getElementsByTagName(\"p\"); // 5> 遍历获取到的p标签 for(var j = 0; j 使用函数进行封装优化 // 通过标签名字来获取页面中的元素 function tag(tagName) { // var dvs = document.getElementsByTagName(tagName); // return dvs; return document.getElementsByTagName(tagName); } // 封装一个设置样式的函数 function setStyle(arr) { for(var i = 0; i 使用面向对象的方式 // 更好的做法：是将功能相近的代码放到一起 var itcast = { getEle: { tag: function (tagName) { return document.getElementsByTagName(tagName); }, id: function (idName) { return document.getElementById(idName); } }, setCss: { setStyle: function (arr) { for(var i = 0; i 举例2 创建一个 div 标签, 并设置其样式, 加入页面中 传统的处理办法 //1. 首先找对象 //2. 任何操作应该交给对象完成 // 任务需求: // 1> 创建一个 div 标签 var div = document.createElement( 'div' ); // 2> 将 div 加到页面中 document.body.appendChild( div ); // 3> 设置 div 的样式 div.style.border = '1px dashed red'; div.style.width = '400px'; div.style.height = '300px'; 使用面向对象的方式 // 面向对象的方式去思考: // 1, 抽取对象( 名词提炼法 ): div, body // 2, 分析属性与方法( 动词提炼 ): 加到, 设置样式 var divTag = new DivTag(); // 内部应该创建 dom 对象 // 构造函数内部应该创建 dom 对象 div, 同时将其设置为属性 // 需要一个 div 的构造函数 function DivTag() { this.DOM = document.createElement( 'div' ); this.__加到 = function ( node ) { // 需要将 this.DOM 加到 node 中 node.appendChild( this.DOM ); }; this.__设置样式 = function ( name, value ) { // 设置 this.DOM 的样式 this.DOM.style[ name ] = value; }; } var divTag = new DivTag(); divTag.__设置样式( 'border', '1px solid red' ); divTag.__设置样式( 'width', '400px' ); divTag.__设置样式( 'height', '100px' ); divTag.__设置样式( 'backgroundColor', 'pink' ); "},"Sources/2.3_构造函数.html":{"url":"Sources/2.3_构造函数.html","title":"2.3 构造函数","keywords":"","body":"构造函数的作用 function Person(name, age){ this.name = name; this.age = age; } //断点调试，进行类型查看 var p1 = new Person(); var p2 = new Object(); var p3 = new Date(); var p4 = new RegExp(); var p5 = {}; 1.构造函数是干什么用的？ 在JavaScript中，构造函数是给对象添加属性，初始化属性用的。 2. 对象的创建过程 var p = new Person(); 以上面这个p对象创建为例： 首先使用new关键字创建对象，类似于使用{},这个时候创建出来的对象是一个\"没有任何成员\"的对象。这里需要注意两点： 使用new关键字创建的对象，对象的类型就是创建这个对象使用的构造函数的函数名 使用{}创建对象，对象的类型一定是Object，相当于使用了new Object() 使用构造函数为其初始化成员 在构造函数调用开始的时候，有一个赋值操作，也就是让this = 刚创建出来的对象 在构造函数中，this就代表刚创建出来的对象 在构造函数中，利用对象的动态特性，为对象添加成员 "},"Sources/2.4_面向对象的三大特性.html":{"url":"Sources/2.4_面向对象的三大特性.html","title":"2.4 面向对象的三大特性","keywords":"","body":"面向对象的特性 JavaScript面向对象的特性 1. 封装性 对象是将数据与功能组合到一起, 即封装 js 对象就是 键值对的集合 键值如果是数据( 基本数据, 复合数据, 空数据 ), 就称为属性 如果键值是函数, 那么就称为方法 对象就是将属性与方法封装起来 方法是将过程封装起来 2. 继承性 所谓继承就是自己没有, 别人有,拿过来为自己所用, 并成为自己的东西 2.1. 传统继承基于模板 子类可以使用从父类继承的属性和方法。 class Person { string name; int age; } class Student : Person { } var stu = new Student(); stu.name 即：让某个类型的对象获得另一个类型的对象的属性的方法 2.2. js 继承基于对象 在JavaScript中，继承就是当前对象可以使用其他对象的方法和属性。 js继承实现举例：混入（mix） function mix ( o1, o2 ) { for ( var k in o2 ) { o1[ k ] = o2[ k ]; } } 3. 多态性（基于强类型）只做了解 把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。 动物 animal = new 子类(); // 子类：麻雀、狗、猫、猪、狐狸... 动物 animal = new 狗(); animal.叫(); "},"Sources/2.5.1_传统构造函数存在的问题.html":{"url":"Sources/2.5.1_传统构造函数存在的问题.html","title":"2.5.1 传统构造函数存在的问题","keywords":"","body":"传统构造函数存在的问题 1. 发现问题 现有构造函数如下： function Person(name, age){ this.name = name; this.age = age; this.sayHi = function(){ console.log(\"你好\"); } } 调用该构造函数创建对象，并对比创建出来的对象的sayHi方法： var p = new Person(\"张三\", 18); var p1 = new Person(\"李四\", 19); console.log(p.sayHi == p1.sayHi); //输出结果为false 由于每个对象都是由new Person创建出来的，因此每创建一个对象，函数sayHi都会被重新创建一次，这个时候，每个对象都拥有一个独立的，但是功能完全相同的方法。 功能相同的函数，完全没有必要再内存中存在这么多份。所以就造成了资源浪费。 2. 解决问题 这里最好的办法就是将函数体放在构造函数之外. 在构造函数中只需要引用该函数即可。 function sayHello(){ console.log(\"你好\"); } function Person(name, age){ this.name = name; this.age = age; this.sayHi = sayHello; } //调用该构造函数创建对象，并对比创建出来的对象的sayHi方法 var p = new Person(\"张三\", 18); var p1 = new Person(\"李四\", 19); console.log(p.sayHi == p1.sayHi); //输出结果为true 这样写依然存在问题： 全局变量增多，会增加引入框架命名冲突的风险 代码结构混乱，会变得难以维护 "},"Sources/2.5.2_使用原型解决构造函数问题.html":{"url":"Sources/2.5.2_使用原型解决构造函数问题.html","title":"2.5.2 使用原型解决构造函数问题","keywords":"","body":"使用原型解决构造函数问题 1. 关键点 每一个函数在定义的时候，都会有跟它关联的一个对象被创建出来 每一个由构造函数创建出来的对象，都会默认的和构造函数的神秘对象关联 当使用一个方法进行属性或者方法访问的时候，会先在当前对象内查找该属性和方法 如果当前对象内未找到，就回去跟它关联的神秘对象内进行查找 function Person(name, age){ this.name = name; this.age = age; this.sayHi = function(){ console.log(\"Hello!\"); }; } var p = new Person(\"张三\", 18); p.sayHi(); //当前对象内有这个方法，所以不会去神秘对象内进行查找 var p1 = new Person(\"李四\", 19); p1.sayHello(); //当前对象没没有找到这个方法，所以去神秘对象内进行查找 问题来了，如何访问到这个神秘对象呢？ //可以通过 构造函数.prototype 访问这个神秘对象 console.log(Person.prototype); 当尝试给这个对象新增一个方法之后: Person.prototype.sayHello = function(){ console.log(\"我是神秘对象中的方法\"); }; 使用p,p1都可以访问这个方法： p.sayHello(); p1.sayHello(); 总结： 所有对象共享神秘对象(构造函数.prototype)内的属性和方法。 2. 解决方案 既然所有对象共享神秘对象(构造函数.prototype)内的属性和方法。我们只需要将需要共享的东西，也就是重复占用内存的东西，全部都放到 神秘对象(构造函数.prototype)中，那么所有对象就都可以使用，并且内存里面也只有一份了。 改造构造函数 function Person(name, age){ this.name = name; this.age = age; } Person.prototype.sayHi = function(){ console.log(\"你好\"); }; //测试 var p = new Person(\"张三\", 18); var p1 = new Person(\"李四\", 19); console.log(p.sayHi == p1.sayHi); //输出true 3.常见的错误 3.1. 将属性写在神秘对象（构造函数.prototype）内 function Car(name){ this.name = name; } function Person() {} Person.prototype.name = '张三'; //基本类型的属性影响不大 Person.prototype.car = new Car(\"法拉利\"); //引用类型的属性，会被所有的对象共享 var p = new Person(); 3.2. 赋值的错误 function Person() {} Person.prototype.name = '张三'; var p1 = new Person(); var p2 = new Person(); p1.name = '李四'; console.log( p1.name ); console.log( p2.name ); // 如果是访问数据, 当前对象中如果没有该数据就到构造函数的原型属性中去找 // 如果是写数据, 当对象中有该数据的时候, 就是修改值; 如果对象没有该数据, 那么就添加值 "},"Sources/2.5.3_原型相关概念.html":{"url":"Sources/2.5.3_原型相关概念.html","title":"2.5.3 原型相关概念","keywords":"","body":"原型相关的概念 1. 神秘对象称与构造函数 神秘对象就是构造函数的 \"原型属性\" 简称原型 (构造函数的原型) 2. 神秘对象与构造函数所创建出来的对象 神秘对象针对构造函数创建出来的对象称为 \"原型对象\" 简称原型 (对象的原型） 3. 原型继承 构造函数创建的对象 继承自 构造函数的原型属性 构造函数创建的对象 继承自 该对象的原型对象 原型中的成员, 可以直接被实例对象所使用 实例对象直接 \"含有\" 原型中的成员 因此实例对象 继承自 原型 这样的继承就是 \"原型继承\" "},"Sources/2.5.4_原型的使用.html":{"url":"Sources/2.5.4_原型的使用.html","title":"2.5.4 原型的使用","keywords":"","body":"原型的使用 1. 使用对象的动态特性 function Person () { } Person.prototype.func = function () { console.log( 'something' ); }; var p = new Person(); p.func(); 2. 直接替换原型对象 function Person () { }; Person.prototype = { func: function () { console.log( '22222' ); } }; var p = new Person(); p.func(); 3. 直接替换原型会出现的问题 function Person () { } Person.prototype.func = function () { console.log( 'something' ); }; var p = new Person(); Person.prototype.func = function () { console.log( 'something' ); }; var p1 = new Person(); p.func(); p1.func(); 替换原型之后，在替换前创建出来的对象和替换后创建出来的对象的原型对象不一致 "},"Sources/2.5.5_proto.html":{"url":"Sources/2.5.5_proto.html","title":"2.5.5 __proto__","keywords":"","body":"对象的__proto__属性 1. 标识符命名规则 区分大小写,Name和name是两个不同的变量 标识符可以以下划线_,美元符$或者字母开头，但是不能是数字 标识符可以由下划线_，美元符$，字母，数字组成 2. 神秘对象的访问 构造函数的prototype属性 之前我们访问神秘对象的时候，使用的是原型属性 prototype function Person(){} //通过构造函数的原型属性prototype可以直接访问原型 Person.prototype; 在之前是无法通过构造函数创建出来的对象访问原型的 function Person(){} var p = new Person(); //以前不能直接通过p来访问神秘对象 实例对象的__proto__属性 __proto__属性最早是火狐浏览器引入的，用以通过实例对象来访问原型，这个属性在早期是非标准的属性 有了__proto__属性，就可以通过构造函数创建出来的对象直接访问神秘对象 function Person(){} var p = new Person(); //实例对象的__proto__属性可以方便的访问到原型对象 p.__proto__; //既然使用构造函数的`prototype`和实例对象的`__proto__`属性 //都可以访问原型对象 //就有如下结论 p.__proto__ === Person.prototype; 3. __proto__属性的用途 可以用来访问原型 在实际开发中除非有特殊的需求，不要轻易的使用实例对象的__proto__属性去修改原型的成员， 在调试过程中，可以轻易的查看原型的成员 tips: 早期如何通过实例对象访问原型？ 可以使用实例对象访问构造函数属性constuctor var p = new Person(); p.constructor.prototype; 4. 给实例继承自原型的属性赋值需要注意的问题 function Person(){}; Person.prototype.name = \"周华健\"; var o1 = new Person(); var o2 = new Person(); o1.name = \"李宗盛\"; //这里修改的不是原型对象的name属性，而是给o1自己新增了一个name属性，进行了赋值 //我们可以对比一下o1和o2的name值 console.log(o1.name , o2.name); "},"Sources/2.6_继承的概念及实现方式.html":{"url":"Sources/2.6_继承的概念及实现方式.html","title":"2.6 继承的概念及实现方式","keywords":"","body":"继承 继承的概念 在JavaScript中，继承就是当前对象可以使用其他对象的方法和属性。 var animal = { name:\"Animal\", sex:\"male\", age:5, bark:function(){ console.log(\"Animal bark\"); } }; var dog = {}; //当前有两个对象，一个animal,一个dog //dog没有属性和方法 //但是我们知道，dog属于animal，所以animal的方法和属性，都可以被dog使用 //如何让dog可以使用animal的属性和方法呢？ //通过继承就可以实现 继承的实现方式 在上一节内容中，最终的结论就是可以通过继承来让dog对象可以使用animal对象的属性和方法，那怎么实现继承呢？ 1. 最简单的继承实现 直接遍历父对象的属性，将所有的属性加到当前对象上 var animal = { name:\"Animal\", sex:\"male\", age:5, bark:function(){ console.log(\"Animal bark\"); } }; var dog = {}; for (var k in animal){ dog[k]= animal[k]; } 2. 原型继承 每一个构造函数都有prototype原型属性，通过构造函数创建出来的对象都继承自该原型属性。所以可以通过更改构造函数的原型属性来实现继承。 function Dog(){ this.type = \"yellow Dog\"; } function extend(obj1, obj2){ for (var k in obj2){ obj1[k] = obj2[k]; } }; //使用混入的方式，将属性和方法添加到构造函数的原型属性上，构造函数所创建出来的实例就都有了这些属性和方法。 extend(Dog.prototype, { name:\"\", age:\"\", sex:\"\", bark:function(){} }) //使用面向对象的思想把extend方法重新封装 //extend是扩展的意思，谁要扩展就主动调用extend这个方法 //所以extend应该是对象的方法，那现在我们要扩展的是构造函数的原型对象 //所以给构造函数的原型对象添加一个extend方法 //如下： Dog.prototype.extend = function(obj){ for (var k in obj){ this[k]=obj[k]; } } //调用方式就变成了下面这种形式 Dog.prototype.extend({ name:\"\", age:\"\", sex:\"\", bark:function(){} }); "},"Sources/2.7_原型三角绘制.html":{"url":"Sources/2.7_原型三角绘制.html","title":"2.7 原型三角绘制","keywords":"","body":"原型三角形绘制 请尝试绘制如下三种情况的原型三角形图： 练习一： function Person() { this.name = '张三'; this.sayHello = function () { } } var p = new Person(); 练习二： function Person() { this.name = '张三'; } Person.prototype.sayHello = function () { } var p = new Person(); 练习三： function Person() { this.name = '张三'; } Person.prototype = { sayHello: function () { } }; var p = new Person(); "},"Sources/2.8_属性搜索原则.html":{"url":"Sources/2.8_属性搜索原则.html","title":"2.8 属性搜索原则","keywords":"","body":"属性搜索原则 访问一个对象的成员的时候，首先是在实例中找，没有找到, 就去原型中找, 但是原型中没有怎么办? 原型链 每一个对象都有原型属性，那么对象的原型属性也会有原型属性，所以这样就形成了一个链式结构，我们称之为原型链。 属性搜索原则 所谓的属性搜索原则，也就是属性的查找顺序，在访问对象的成员的时候，会遵循如下的原则: 首先在当前对象中查找，如果找到，停止查找，直接使用，如果没有找到，继续下一步 在该对象的原型中查找，如果找到，停止查找，直接使用，如果没有找到，继续下一步 在该对象的原型的原型中查找，如果找到，停止查找，直接使用，如果没有找到，继续下一步。 继续往上查找，直到查找到Object.prototype还没有, 那么是属性就返回 undefied，是方法，就报错xxx is not a function。 "},"Sources/2.9.1_原型链结构.html":{"url":"Sources/2.9.1_原型链结构.html","title":"2.9.1 原型链结构","keywords":"","body":"原型链结构 凡是对象就有原型, 原型又是对象, 因此凡是给定义一个对象, 那么就可以找到他的原型, 原型还有原型. 那么如此下去, 就构成一个对象的序列. 称该结构为原型链. 使用构造函数创建出对象, 并且没有利用赋值的方式修改原型, 就说该对象保留默认的原型链. 默认原型链结构是什么样子呢? function Person() { } var p = new Person(); // p 具有默认的原型链 默认的原型链结构就是: 当前对象 -> 构造函数.prototype -> Object.prototype -> null 在实现继承的时候, 有时会利用替换原型链结构的方式实现原型继承, 那么原型链结构就会发生改变 function ItcastCollection () { } ItcastCollection.prototype = []; var arr = new ItcastCollection(); // arr -> [] -> Array.prototype -> Object.prototype -> null // var arr = new Array(); 练习： 描述出{}的原型链结构 描述出[]的原型链结构 "},"Sources/2.9.2_原型式继承.html":{"url":"Sources/2.9.2_原型式继承.html","title":"2.9.2 原型式继承","keywords":"","body":"原型式继承 观察：DOM对象的原型链 原型式继承就是利用修改原型链的结构( 增加一个节点, 删除一个节点, 修改节点中的成员 ), 来使得实例对象可以使用整条链中的所有成员. 绘制原型链结构 注意：函数也有__proto__属性，暂时不考虑这个！ 观察如下代码，绘制相应的原型链结构图: function Person(){}; var p = new Person(); 对应的原型链结构图为： 练习： 绘制{}的原型链结构图 绘制[]的原型链结构图 注意： 在 js 中, 所有的对象字面量在解析以后, 就是一个具体的对象了. 那么可以理解为 调用的 对应的构造方法. 例如在代码中写上 {}, 就相当于new Object() 例如代码中有 [], 就相当于new Array() 例如代码中有 /./, 就相当于new RegExp( '.' ) 注意: 在底层理论执行的过程中, 是否有调用构造函数, 不一定. 和浏览器的版本有关. 练习： 绘制如下代码的原型链结构: var o = { appendTo: function ( dom ) { } }; function DivTag() {} DivTag.prototype = o; var div = new DivTag(); "},"Sources/2.10.1_Object.prototype成员介绍.html":{"url":"Sources/2.10.1_Object.prototype成员介绍.html","title":"2.10.1 Object.prototype成员介绍","keywords":"","body":"Object.prototype成员介绍 Object.prototype常用成员 成员 描述 Object.prototype.__proto__ 指向当对象被实例化的时候，用作原型的对象。 Object.prototype.hasOwnProperty() 返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。 Object.prototype.isPrototypeOf() 返回一个布尔值，表示指定的对象是否在本对象的原型链中。 Object.prototype.toString() 返回对象的字符串表示。 Object.prototype.valueOf() 返回指定对象的原始值。 "},"Sources/2.10.2_Function.html":{"url":"Sources/2.10.2_Function.html","title":"2.10.2 Function","keywords":"","body":"函数的构造函数Function 在 js 中 使用Function可以实例化函数对象。也就是说在 js 中函数与普通对象一样, 也是一个对象类型. 函数是 js 中的一等公民. 函数是对象, 就可以使用对象的动态特性 函数是对象, 就有构造函数创建函数 函数是函数, 可以创建其他对象 函数是唯一可以限定变量作用域的结构 要解决的问题 Function 如何使用 Function 与函数的关系 函数的原型链结构 "},"Sources/2.10.2.1_Function的使用.html":{"url":"Sources/2.10.2.1_Function的使用.html","title":"1) Function的使用","keywords":"","body":"Function 的使用 语法: //Function函数所有的参数全都是字符串 //Function函数的作用就是将所有的参数组合起来，变成一个函数 //1、如果只传一个参数，那么这个函数必然是函数体 //2、如果传多个参数，那么最后一个参数表示函数体，前面的参数代表将要创建的函数的参数 //3、如果不传参数，表示创建一个空函数 new Function(arg1, arg2, arg3, ..., argN, body); 创建一个打印一句话的函数 //传统的方式 function foo(){ console.log(\"你好\"); } //使用Function var func = new Function(\"console.log('你好');\"); 这里两种方式创建出来的函数功能是一样的。 创建一个空函数 //传统的方式 function foo(){} //Function var func = new Function(); 创建一个有参数的函数 //传统的方式 function foo(num){ console.log(num); } //Function var func = new Function(){\"num\", \"console.log(num);\"}; 练习: 利用 Function 创建一个函数, 要求传入两个数字, 打印其和 var func = new Function( 'num1', 'num2', 'console.log( num1 + num2 );' ); 利用 Function 创建一个函数, 要求允许函数调用时传入任意个数参数, 并且函数返回这些数字中最大的数字. 利用 Function 创建一个求三个数中最大数的函数. // 传统 function foo ( a, b, c ){ var res = a > b ? a : b; res = res > c ? res : c; return res; } // Function var func = new Function( 'a', 'b', 'c', 'var res = a > b ? a : b;res = res > c ? res : c;return res;' ) "},"Sources/2.10.2.2_参数代码太长的问题.html":{"url":"Sources/2.10.2.2_参数代码太长的问题.html","title":"2) 参数代码太长的问题","keywords":"","body":"解决代码太长的问题 利用+连接字符串 var func = new Function( 'a', 'b', 'c', 'var res = a > b ? a : b;' + 'res = res > c ? res : c;' + 'return res;' ); 利用字符串特性 function foo ( a, b, c ) { var res = a > b ? a : b; res = res > c ? res : c; return res; } var func = new Function( 'a', 'b', 'c', 'return foo( a, b, c );'); ES6 语法（很少有浏览器实现） 使用键盘左上角的` 表示可换行字符串的界定符，之前我们用的是单引号或者双引号来表示一个字符串字面量，在ES6中可以用反引号来表示该字符串可换行。 (最终)利用 DOM 的特性完成该方法 var res = a > b ? a : b; res = res > c ? res : c; return res; var txt = document.getElementbyId(\"code).innerHtml + ' '; var func = new Function('a', 'b', 'c', txt); "},"Sources/2.10.3_静态成员和实例成员.html":{"url":"Sources/2.10.3_静态成员和实例成员.html","title":"2.10.3 静态成员和实例成员","keywords":"","body":"静态成员与实例成员的概念 静态成员和实例成员这两个概念其实也是从面相对象的编程语言中引入的，对应到JavaScript中的理解为： 静态成员 静态成员是指静态属性和静态方法，所谓静态，就是有构造函数提供的。 实例成员 实例成员是值实例属性和实例方法，所谓实例，就是由构造函数创建出来的对象。 举例说明： function Person(){ this.name = \"zs\", this.sayHello = function(){ console.log(\"Hello World\"); } } //下面这个sayHi方法就是构造函数自己的方法，也就是静态方法 Person.sayHi = function(){ console.log(\"I'm a Person\"); } //原型属性属于构造函数，所以原型属性是静态属性 Person.prototype = {}; var p = new Person(); //这里的name是构造函数创建出来的实例对象的属性，所以是实例属性 p.name = \"李四\"; //这里的sayHello也是构造函数创建出来的实例对象的方法，所以是实例方法 p.sayHello(); 提示： 一般工具型方法都有静态成员提供, 一般与实例对象有关的方法由实例成员表示. 工具方法：比如jQuery.Ajax()、jQuery.trim()、jQuery.Each() "},"Sources/2.10.4_arguments对象.html":{"url":"Sources/2.10.4_arguments对象.html","title":"2.10.4 arguments对象","keywords":"","body":"arguments对象 在每一个函数调用的过程中, 函数代码体内有一个默认的对象arguments, 它存储着实际传入的所有参数。 arguments是一个伪数组对象. 它表示在函数调用的过程中传入的所有参数的集合。在函数调用过程中不规定参数的个数与类型, 可以使得函数调用变得非常灵活性。 JavaScript中的函数并没有规定必须如何传参： 定义函数的时候不写参数, 一样可以调用时传递参数 定义的时候写了参数, 调用的时候可以不传参 定义的时候写了一个参数, 调用的时候可以随意的传递多个而参数 在代码设计中, 如果需要函数带有任意个参数的时候, 一般就不带任何参数, 所有的参数利用arguments对象来获取. 一般的函数定义语法, 可以写成: function foo ( /* ... */ ) { } 练习: 利用 Function 创建一个函数, 要求允许函数调用时传入任意个数参数, 并且函数返回这些数字中最大的数字. function foo ( ) { // 所有的参数都在 arguments 中. 将其当做数组使用 // 问题已转换成在有一个数组中求最大值 var args = arguments; var max = args[ 0 ]; for ( var i = 1; i 练习: 利用 Function 写一个函数, 要求传入任意个数字 求和 "},"Sources/2.10.5_深拷贝和浅拷贝.html":{"url":"Sources/2.10.5_深拷贝和浅拷贝.html","title":"2.10.5 深拷贝和浅拷贝","keywords":"","body":"深拷贝和浅拷贝 1. 浅拷贝和深拷贝的概念 1.1. 什么是浅拷贝？ 如果拷贝的时候，只针对当前对象的属性进行拷贝，而不考虑引用类型的属性，那么这个就是浅拷贝 比如下面这个对象： var p = { name:\"张三\", age:18, car:{ name:\"Ferrari\" } }; /* 浅拷贝的代码 */ //经过深拷贝之后，我们得到一个p对象深拷贝的副本 pCopy 浅拷贝之后，内存中的存储情况： 1.2. 什么是深拷贝？ 如果拷贝的时候，将数据所有的引用结构都拷贝一份，拷贝所得的数据在内存中是完全独立的，那么这个就是深拷贝 比如下面这个对象： var p = { name:\"张三\", age:18, car:{ name:\"Ferrari\" } }; /* 深拷贝的代码 */ //经过深拷贝之后，我们得到一个p对象深拷贝的副本 pCopy 深拷贝之后，内存中的存储情况： 2. 浅拷贝和深拷贝的代码实现 浅拷贝代码实现： var p = { name:\"张三\", age:18, car:{ name:\"Ferrari\" } } //对p对象进行浅拷贝 var pCopy = {}; pCopy.name = p.name; pCopy.age = p.age; pCopy.car = p.car; 深拷贝代码实现： var p = { name:\"张三\", age:18, car:{ name:\"Ferrari\" } } var pCopy = {}; pCopy.name = p.name; pCopy.age = p.age; pCopy.car = {}; pCopy.car.name = p.car.name; 3. 浅拷贝和深拷贝代码封装 浅拷贝封装： var p = { name: '张三', age: 19, copy: function () { // 将当前对象拷贝一份 // 1, 创建对象 var temp = {}; // 2, 复制属性. 在 copy 中使用 this 表示当前对象 for ( var k in this ) { temp[ k ] = this[ k ]; } // 3, 返回对象 return temp; } }; var p2 = p.copy(); p.name = '李四'; p.age = 20; p.gender = '女'; var o = {}; o.func = p.copy; o.func(); 深拷贝封装： var car = { name: '法拉利', deepCopy: function() { // 1, 创建一个对象 var temp = {}; // 2, 拷贝属性, 在判断如果是引用类型需要深拷贝 for ( var k in this ) { if ( typeof this[ k ] === 'object' ) { temp[ k ] = this[ k ].deepCopy(); } else { temp[ k ] = this[ k ]; } } // 3, 返回对象 return temp; } }; var p = { name: '张三', car: car, deepCopy: function () { // 1, 创建一个对象 var temp = {}; // 2, 拷贝属性, 在判断如果是引用类型需要深拷贝 for ( var k in this ) { if ( typeof this[ k ] === 'object' ) { temp[ k ] = this[ k ].deepCopy(); } else { temp[ k ] = this[ k ]; } } // 3, 返回对象 return temp; } } 如果可以保证所有的对象中都有copy方法，那么就可以简化了 写一个deepCopy函数, 每一个对象都使用对象.deepCopy = deepCopy使得当前对象具有拷贝的方法, 那么就可以实现深拷贝了 深拷贝最终版本： var deepCopy = function () { // 1, 创建一个对象 var temp = {}; // 2, 拷贝属性, 在判断如果是引用类型需要深拷贝 for ( var k in this ) { if ( typeof this[ k ] === 'object' ) { temp[ k ] = this[ k ].deepCopy(); } else { temp[ k ] = this[ k ]; } // temp[ k ] = this[ k ]; } // 3, 返回对象 return temp; } var car = { name: '法拉利' }; var p = { name: '张三', age: 19, gender: '男', car: car }; // 让所有的对象都有 拷贝的 方法 car.deepCopy = deepCopy; p.deepCopy = deepCopy; var newP = p.deepCopy(); p.name = '李四'; p.age = 20; p.gender = '女'; p.car.name = '兰博基尼'; "},"Sources/3.1_递归.html":{"url":"Sources/3.1_递归.html","title":"3.1 递归","keywords":"","body":"递归 什么是递归 在程序中，所谓的递归，就是函数自己直接或间接的调用自己。调用自己分两种： 直接调用自己 间接调用自己 就递归而言最重要的就是跳出结构，因为跳出了才可以有结果. 化归思想 化归思想：将一个问题由难化易，由繁化简，由复杂化简单的过程称为化归，它是转化和归结的简称。 递归思想就是将一个问题转换为一个已解决的问题来实现 假如有一个函数f, 如果它是递归函数的话, 那么也就是说函数体内的问题还是转换为 f的形式. function f() { ... f( ... ) ... } 例子: 1, 2, 3, 4, 5, ..., 100 求和 首先假定递归函数已经写好, 假设是foo. 即foo(100)就是求1到100的和 寻找递推关系. 就是n与n-1, 或n-2之间的关系:foo( n ) == n + foo( n - 1 ) var res = foo(100); var res = foo(99) + 100; 将递推结构转换为递归体 function foo(n){ return n + foo( n - 1 ); } 上面就是利用了化归思想： 将 求 100 转换为 求 99 将 求 99 转换为 求 98 ... 将求 2 转换为 求 1 求 1 结果就是 1 即: foo( 1 ) 是 1 将临界条件加到递归体中(求1的结果为1) function foo( n ) { if ( n == 1 ) return 1; return n + foo( n - 1 ); } 练习: 求 1, 3, 5, 7, 9, ... 第n项的结果与前n项和. 序号从0开始 先看求第n项 首先假定递归函数已经写好, 假设是fn. 那么第n项就是fn(n) 找递推关系:fn(n) == f(n-1) + 2 递归体 function fn(n) { return fn(n-1) + 2; } 找临界条件 求 n -> n-1 求 n-1 -> n-2 ... 求 1 -> 0 求 第 0 项, 就是 1 加入临界条件 function fn( n ) { if ( n == 0 ) return 1; return fn( n-1 ) + 2; } 再看求前n项和 假设已完成, sum( n ) 就是前 n 项和 找递推关系: 前 n 项和 等于 第 n 项 + 前 n-1 项的和 递归体 function sum( n ) { return fn( n ) + sum( n - 1 ); } 找临界条件 n == 1结果为 1 加入临界条件 function sum( n ) { if (n == 0) return 1; return fn(n) + sum(n - 1); } 练习 2, 4, 6, 8, 10 第 n 项与 前 n 项和 解题方法和上一题一样。 练习 现有数列: 1, 1, 2, 4, 7, 11, 16, … 求 第 n 项, 求前 n 项和. 求第n项 假设已经得到结果 fn, fn( 10 ) 就是第 10 项 找递推关系 0, 1 => fn( 0 ) + 0 = fn( 1 ) 1, 2 => fn( 1 ) + 1 = fn( 2 ) 2, 3 => fn( 2 ) + 2 = fn( 3 ) ... n-1, n => fn( n-1 ) + n - 1 = fn( n ) 递归体也就清楚了 临界条件是 n == 0 => 1 function fn( n ) { if ( n == 0 ) return 1; return fn( n-1 ) + n - 1; } 前n项和 function sum( n ) { if ( n == 0 ) return 1; return sum( n - 1 ) + fn( n ); } 练习 Fibonacci 数列: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … 求其第 n 项. 递推关系:fn(n) == fn(n-1) + fn(n - 2) function fib( n ) { if ( n == 0 || n == 1 ) return 1; return fib( n - 1 ) + fib( n - 2 ); } 练习 阶乘：一个数字的阶乘表示的是从 1 开始 累乘到这个数字. 例如 3! 表示 1 2 3. 5! 就是 1 2 3 4 5. 规定 0 没有阶乘, 阶乘从1开始。 求n的阶乘 function foo ( n ) { if ( n == 1 ) return 1; return foo( n - 1 ) * n; } 练习 求幂 求幂就是求 某一个数 几次方 2*2 2 的 平方, 2 的 2 次方 求 n 的 m 次方 最终要得到一个函数 power( n, m ) n 的 m 次方就是 m 个 n 相乘 即 n 乘以 (m-1) 个 n 相乘 function power ( n, m ) { if ( m == 1 ) return n; return power( n, m - 1 ) * n; } "},"Sources/3.2.1_词法作用域.html":{"url":"Sources/3.2.1_词法作用域.html","title":"3.2.1 词法作用域","keywords":"","body":"作用域 域，表示的是一个范围，作用域，就是作用范围。 作用域说明的是一个变量可以在什么地方被使用，什么地方不能被使用。 块级作用域 JavaScript中没有块级作用域 { var num = 123; { console.log( num ); } } console.log( num ); 上面这段代码在JavaScript中是不会报错的，但是在其他的编程语言中（C#、C、JAVA）会报错。 这是因为，在JavaScript中没有块级作用域，使用{}标记出来的代码块中声明的变量num，是可以被{}外面访问到的。 但是在其他的编程语言中，有块级作用域，那么{}中声明的变量num，是不能在代码块外部访问的，所以报错。 词法作用域 什么是词法作用域？ 词法( 代码 )作用域, 就是代码在编写过程中体现出来的作用范围. 代码一旦写好, 不用执行, 作用范围就已经确定好了. 这个就是所谓词法作用域. 在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析 如果当前作用规则中有名字了, 就不考虑外面的名字 例子1： var num = 123; function foo() { console.log( num ); } foo(); 例子2： if ( false ) { var num = 123; } console.log( num ); // undefiend 例子3： var num = 123; function foo() { var num = 456; function func() { console.log( num ); } func(); } foo(); 练习： var num1 = 123; function foo1() { var num1 = 456; function foo2() { num1 = 789; function foo3 () { console.log( num1 ); } foo3(); } foo2(); } foo1(); console.log( num1 ); 面试题 var num = 123; function func1(){ console.log(num); } function func2(){ var num = 456; func1(); } "},"Sources/3.2.2_变量名提升.html":{"url":"Sources/3.2.2_变量名提升.html","title":"3.2.2 变量名提升","keywords":"","body":"变量名提升 JavaScript是解释型的语言，但是他并不是真的在运行的时候逐句的往下解析执行。 我们来看下面这个例子： func(); function func(){ alert(\"Funciton has been called\"); } 在上面这段代码中，函数func的调用是在其声明之前，如果说JavaScript代码真的是逐句的解析执行，那么在第一句调用的时候就会出错，然而事实并非如此，上面的代码可以正常执行，并且alert出来Function has been called。 所以，可以得出结论，JavaScript并非仅在运行时简简单单的逐句解析执行！ JavaScript 预解析 JavaScript引擎在对JavaScript代码进行解释执行之前，会对JavaScript代码进行预解析，在预解析阶段，会将以关键字var和function开头的语句块提前进行处理。 关键问题是怎么处理呢？ 当变量和函数的声明处在作用域比较靠后的位置的时候，变量和函数的声明会被提升到作用域的开头。 重新来看上面的那段代码 func(); function func(){ alert(\"Funciton has been called\"); } 由于JavaScript的预解析机制，上面的代码就等效于： function func(){ alert(\"Funciton has been called\"); } func(); 看完函数声明的提升，再来看一个变量声明提升的例子： alert(a); var a = 1; 由于JavaScript的预解析机制，上面这段代码，alert出来的值是undefined，如果没有预解析，代码应该会直接报错a is not defined，而不是输出值。 Wait a minute, 不是说要提前的吗？那不是应该alert出来1，为什么是undefined? 那么在这里有必要说一下声明、定义、初始化的区别。其实这几个概念是C系语言的人应该都比较了解的。 行为 说明 声明 告诉编译器/解析器有这个变量存在,这个行为是不分配内存空间的,在JavaScript中，声明一个变量的操作为：var a; 定义 为变量分配内存空间，在C语言中，一般声明就包含了定义，比如：int a;,但是在JavaScript中，var a;这种形式就只是声明了。 初始化 在定义变量之后，系统为变量分配的空间内存储的值是不确定的，所以需要对这个空间进行初始化，以确保程序的安全性和确定性 赋值 赋值就是变量在分配空间之后的某个时间里，对变量的值进行的刷新操作（修改存储空间内的数据) 所以我们说的提升，是声明的提升。 那么再回过头看，上面的代码就等效于： var a; //这里是声明 alert(a);//变量声明之后并未有初始化和赋值操作，所以这里是 undefined a = 1; 复杂点的情况分析 通过上一小节的内容，我们对变量、函数声明提升已经有了一个最基本的理解。那么接下来，我们就来分析一些略复杂的情况。 函数同名 观察下面这段代码: func1(); function func1(){ console.log('This is func1'); } func1(); function func1(){ console.log('This is last func1'); } 输出结果为： This is last func1 This is last func1 原因分析：由于预解析机制，func1的声明会被提升，提升之后的代码为： function func1(){ console.log('This is func1'); } function func1(){ console.log('This is last func1'); } func1(); func1(); 同名的函数，后面的会覆盖前面的，所以两次输出结果都是This is last func1。 变量和函数同名 alert(foo); function foo(){} var foo = 2; 当出现变量声明和函数同名的时候，只会对函数声明进行提升，变量会被忽略。所以上面的代码的输出结果为 function foo(){} 我们还是来把预解析之后的代码展现出来: function foo(){}; alert(foo); foo = 2; 再来看一种 var num = 1; function num () { alert( num ); } num(); 代码执行结果为： Uncaught TypeError: num is not a function 直接上预解析后的代码： function num(){ alert(num); } num = 1; num(); 预解析是分作用域的 声明提升并不是将所有的声明都提升到window对象下面，提升原则是提升到变量运行的环境(作用域)中去。 function showMsg() { var msg = 'This is message'; } alert(msg); // msg未定义 还是直接把预解析之后的代码写出来： function showMsg() { var msg; msg = 'This is message'; } alert(msg); // msg未定义 预解析是分段的 分段，其实就分script标签的 func(); // 输出 AA2; function func(){ console.log('AA1'); } function func(){ console.log('AA2'); } function func(){ console.log('AA3'); } 在上面代码中，第一个script标签中的两个func进行了提升，第二个func覆盖了第一个func，但是第二个script标签中的func并没有覆盖上面的第二个func。所以说预解析是分段的。 tip:但是要注意，分段只是单纯的针对函数，变量并不会分段预解析。 函数表达式并不会被提升 func(); var func = function(){ alert(\"我被提升了\"); }; 这里会直接报错，func is not a function，原因就是函数表达式，并不会被提升。只是简单地当做变量声明进行了处理，如下： var func; func(); func = function(){ alert(\"我被提升了\"); } 条件式函数声明 console.log(typeof func); if(true){ function(){ return 1; } } console.log(typeof func); 上面这段代码，就是所谓的条件式函数声明，这段代码在Gecko引擎中打印\"undefined\"、\"function\"；而在其他浏览器中则打印\"function\"、\"function\"。 原因在于Gecko加入了ECMAScript以外的一个feature：条件式函数声明。 Conditionally created functions Functions can be conditionally declared, that is, a function declaration can be nested within an if statement. Note: Although this kind of function looks like a function declaration, it is actually an expression (or statement), since it is nested within another statement. See differences between function declarations and function expressions. Note中的文字说明，条件式函数声明的处理和函数表达式的处理方式一样，所以条件式函数声明没有声明提升的特性。 "},"Sources/3.2.3_作用域链.html":{"url":"Sources/3.2.3_作用域链.html","title":"3.2.3 作用域链","keywords":"","body":"作用域链 什么是作用域链 只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。 凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。 例如： function f1() { function f2() { } } var num = 456; function f3() { function f4() { } } 绘制作用域链的步骤: 看整个全局是一条链, 即顶级链, 记为 0 级链 看全局作用域中, 有什么成员声明, 就以方格的形式绘制到 0 级练上 再找函数, 只有函数可以限制作用域, 因此从函数中引入新链, 标记为 1 级链 然后在每一个 1 级链中再次往复刚才的行为 变量的访问规则 首先看变量在第几条链上, 在该链上看是否有变量的定义与赋值, 如果有直接使用 如果没有到上一级链上找( n - 1 级链 ), 如果有直接用, 停止继续查找. 如果还没有再次往上刚找... 直到全局链( 0 级 ), 还没有就是 is not defined 注意,同级的链不可混合查找 练习：绘制作用域链 function f1() { var num = 123; function f2() { console.log( num ); } f2(); } var num = 456; f1(); 如何分析代码 在分析代码的时候切记从代码的运行进度上来分析, 如果代码给变量赋值了, 一定要标记到图中 如果代码比较复杂, 可以在图中描述代码的内容, 有事甚至需要将原型图与作用域图合并分析 练习 var num = 123; function f1() { console.log( num ); } function f2() { var num = 456; f1(); } f2(); 练习 var num = 123; function f1() { console.log( num ); } function f2() { num = 456; f1(); } f2(); 补充 声明变量使用`var`, 如果不使用`var`声明的变量就是全局变量( 禁用 ) 因为在任何代码结构中都可以使用该语法. 那么再代码维护的时候会有问题. 所以除非特殊原因不要这么用. 下面的代码的错误 function foo () { var i1 = 1 // 局部 i2 = 2, // 全局 i3 = 3; // 全局 } 此时注意 var arr = []; for ( var i = 0; i "},"Sources/3.3_闭包.html":{"url":"Sources/3.3_闭包.html","title":"3.3 闭包","keywords":"","body":"闭包 闭包的概念 闭包从字面意思理解就是闭合, 包起来. 简单的来说闭包就是,一个具有封闭的对外不公开的, 包裹结构, 或空间. 在JavaScript中函数可以构成闭包. 一般函数是一个代码结构的封闭结构, 即包裹的特性, 同时根据作用域规则, 只允许函数访问外部的数据, 外部无法访问函数内部的数据, 即封闭的对外不公开的特性. 因此说函数可以构成闭包. 闭包要解决什么问题？ 闭包内的数据不允许外界访问 要解决的问题就是间接访问该数据 函数就可以构成闭包, 要解决的问题就是访问到函数内部的数据 我们观察下面的函数foo，在foo内部有一个变量num，能否在函数外部访问到这个变量num呢？ function foo () { var num = 123; return num; } var res = foo(); console.log( res ); // => 123 分析： 在上面的代码中，确实可以访问到num这个函数内部的变量。但是能不能多次访问呢？ 不能，因为每次访问都得重新调用一次foo函数，每次调用都会重新创建一个num = 123，然后返回。 解决思路 函数内的数据不能直接在函数外被访问，是因为作用域的关系，上级作用域不能直接访问下级作用域中的数据。 但是如果反过来，下级作用域可以直接访问上级作用域中的数据。那么如果在函数foo内定义一个函数，那么在这个内部函数中是可以直接访问foo中的num的。 function foo() { var num = Math.random(); function func() { return num; } return func; } var f = foo(); // f可以直接访问num，而且多次访问，访问的也是同一个，并不会返回新的num var res1 = f(); var res2 = f(); 如何获得超过一个数据 函数的返回值只能有一个，那按照上面的方法，我们只能对函数内部的一个数据进行操作。怎么操作函数内的多个数据呢？ 可以使用对象，代码如下： function foo () { var num1 = Math.random(); var num2 = Math.random(); //可以将多个函数包含在一个对象内进行返回，这样就能在函数外部操作当前函数内的多个变量 return { num1: function () { return num1; }, num2: function () { return num2; } } } 如何完成读取一个数据和修改这个数据 前面讲的都是如何去获取函数内部的数据，接下来我们考虑如何修改函数内部的数据。 同样，也是使用内部的函数进行操作。 function foo() { var num = Math.random(); //分别定义get和set函数，使用对象进行返回 return { //get_num负责获取数据 get_num: function() { return num; }, //set_num负责设置数据 set_num: function(value) { num = value; } } } 闭包的基本结构 一般闭包要解决的的问题就是要想办法间接的获得函数内数据的使用权. 那么我们的可以总结出一个基本的使用模型. 写一个函数, 函数内定义一个新函数, 返回新函数, 用新函数获得函数内的数据 写一个函数, 函数内定义一个对象, 对象中绑定多个函数( 方法 ), 返回对象, 利用对象的方法访问函数内的数据 "},"Sources/3.4_函数的四种调用模式.html":{"url":"Sources/3.4_函数的四种调用模式.html","title":"3.4 函数的四种调用模式","keywords":"","body":"函数的调用模式 函数模式 特征:就是一个简单的函数调用，函数名前面没有任何的引导内容 function foo(){} var func = function(){} foo(); func(); (function(){})(); this在函数模式中的含义： this在函数中表示全局对象，在浏览器中是window对象 方法模式 特征: 方法一定是依附于一个对象, 将函数赋值给对象的一个属性, 那么就成为了方法. function f() { this.method = function () {}; } var o = { method: function () {} } this在方法模式调用中的含义:表示函数所依附的这个对象 构造器调用模式 由于构造函数只是给 this 添加成员. 没有做其他事情. 而方法也可以完成这个操作, 就 this 而言, 构造函数与方法没有本质区别. 特征:使用 new 关键字, 来引导构造函数. function Person(){ this.name = \"zhangsan\"; this.age = 19; this.sayHello = function(){ }; } var p = new Person(); 构造函数中发this与方法中一样, 表示对象, 但是构造函数中的对象是刚刚创建出来的对象 关于构造函数中return关键字的补充说明 构造函数中不需要return, 就会默认的return this 如果手动的添加return, 就相当于 return this 如果手动的添加return 基本类型; 无效, 还是保留原来 返回this 如果手动添加return null; 或return undefiend, 无效 如果手动添加return 对象类型; 那么原来创建的this就会被丢掉, 返回的是 return后面的对象 创建对象的模式 工厂方法 // 工厂就是用来生产的, 因此如果函数创建对象并返回, 就称该函数为工厂函数 function createPerson( name, age, gender ) { var o = {}; o.name = name; o.age = age; o.gender = gender; return o; } // document.createElement() 构造方法 function Person(name, age, gender){ this.name = name; this.age = age; this.gender = gender; } var p = new Person(\"zhangsan\", 19, \"男\"); 寄生式创建对象 function Person(name, age, gender){ var o = {}; o.name = name; o.age = age; o.gender = gender; return o; } var p = new Person(\"Jack\", 18, \"male\"); 混合式创建 混合式继承就是讲所有的属性放在构造方法里面，然后讲所有的方法放在原型里面，使用构造方法和原型配合起来创建对象。 上下文调用模式 上下文(Context)，就是函数调用所处的环境。 上下文调用，也就是自定义设置this的含义。 在其他三种调用模式中，函数/方法在调用的时候，this的值都是指定好了的，我们没办法自己进行设置，如果尝试去给this赋值，会报错。 上下文调用的语法 //第一种， apply 函数名.apply(对象, [参数]); //第二种， call 函数名.call(对象, 参数); //上面两种方式的功能一模一样，只是在传递参数的时候有差异。 功能描述： 语法中的函数名表示的就是函数本身，使用函数调用模式的时候，this默认是全局对象 语法中的函数名也可以是方法(如:obj.method)，在使用方法模式调用的时候，this默认是指当前对象 在使用apply和call的时候，默认的this都会失效，this的值由apply和call的第一个参数决定 补充说明 如果函数或方法中没有this的操作, 那么无论什么调用其实都一样. 如果是函数调用foo(), 那么有点像foo.apply( window ). 如果是方法调用o.method(), 那么有点像o.method.apply( o ). 参数问题 call和apply在没有后面的参数的情况下(函数无参数, 方法无参数) 是完全一样的. 如下： function foo() { console.log( this ); } foo.apply( obj ); foo.call( obj ); 第一个参数的使用规则: 如果传入的是一个对象, 那么就相当于设置该函数中的 this 为参数 如果不传入参数, 或传入 null. undefiend 等, 那么相当于 this 默认为 window foo(); foo.apply(); foo.apply( null ); foo.call( undefined ); 如果传入的是基本类型, 那么 this 就是基本类型对应的包装类型的引用 number -> Number boolean -> Boolean string -> String 第二个参数的使用规则 在使用上下文调用的时候, 原函数(方法)可能会带有参数, 那么这个参数在上下文调用中使用第二个( 第 n 个 )参数来表示 function foo( num ) { console.log( num ); } foo.apply( null, [ 123 ] ); // 等价于 foo( 123 ); 上下文调用模式的应用 上下文调用只是能修改this, 但是使用的最多的地方上是函数借用. 1. 将伪数组转换为数组 传统的做法： var a = {}; a[ 0 ] = 'a'; a[ 1 ] = 'b'; a.length = 2; // 使用数组自带的方法 concat // 如果参数中有数组会把参数数组展开 // 语法: arr.concat( 1, 2, 3, [ 4, [ 5 ] ] ); // 特点：不修改原数组 var arr = []; var newArr = arr.concat( a ); 由于a是伪数组, 只是长得像数组. 所以上面的代码不能成功，不能使用concat方法。 但是apply方法有一个特性, 可以将数组或伪数组作为参数。（IE8不支持伪数组操作） foo.apply( obj, 伪数组 ); // IE8 不支持 利用apply方法，可以写出以下 //将伪数组 a 作为 apply 的第二个参数 var newArr = Array.prototype.concat.apply( [], a ) 处理数组转换, 实际上就是将元素一个一个的取出来构成一个新数组, 凡是涉及到该操作的方法理论上都可以。 push方法 //用法: arr.push( 1 ); //将这个元素加到数组中, 并返回所加元素的个数 arr.push( 1, 2, 3 ); //将这三个元素依次加到数组中, 返回所加个数 var a = { length: 0 }; // 伪数组 a[ a.length++ ] = 'abc'; // a[ 0 ] = 'abc'; a.length++; a[ a.length++ ] = 'def'; // 使用一个空数组, 将元素一个个放到数组中即可 var arr = []; arr.push( a ); // 此时不会将元素展开, 而是将这个伪数组作为一个元素加到数组中 // 再次利用 apply 可以展开伪数组的特征 arr.push.apply( arr, a ); // 利用 apply 可以展开伪数组的特性, 这里就相当于 arr.push( a[0], a[1] ) 2. 求数组中的最大值 传统的做法 var max = arr[ 0 ]; for ( var i = 1; i max ) { ... } } 在 js 中的Math对象中提供了很多数学函数Math.max( 1,2,3 ) 还是利用 apply 可以展开数组的特性 var arr = [ 123456,12345,1234,345345,234,5 ]; Math.max.apply( null, arr ); 3.借用构造函数继承 function Person ( name, age, gender ) { this.name = name; this.age = age; this.gender = gender; } // 需要提供一个 Student 的构造函数创建学生对象 // 学生也应该有 name, age, gender, 同时还需要有 course 课程 function Student ( name, age, gender, course ) { Person.call( this, name, age, gender ); this.course = course; } "},"Sources/3.5_函数的重复创建问题.html":{"url":"Sources/3.5_函数的重复创建问题.html","title":"3.5 函数的重复创建问题","keywords":"","body":"对象/函数重复创建问题 1. 发现问题： 首先分析如下代码： var arr = []; for(var i = 0; i 由于每次循环都会使用{}创建一个新的对象，所以输出结果为false。 再分析如下代码： var arr = []; for(var i = 0; i 跟第一段代码相似，每次循环都会创建一个新的函数，所以输出结果为false。 函数的功能就是用来封装一段代码，方便再次调用。同样功能的函数本来只需要创建一份就可以方便到处调用，但是在上面第二段代码中，被创建了多次，这样就造成了资源浪费。 我们期望的是如下图所示的情况： 2. 解决方案 可以对上面第二段代码进行如下改进： //先定义该函数 function printOut(){ console.log(\"Hello JavaScript\"); } var arr = []; for(var i = 0; i 3. 实际应用 在实际开发当中，经常会有给多个元素注册同一个功能的时间处理函数的情况，如下： HTML代码 div1 div2 div3 div4 JavaScript代码 var divs = document.getElementsByTagName(\"div\"); for(var i = 0; i 可以看到，上面用来注册事件代码的方式，会造成同一个功能的函数在内存中创建多个副本出来，这里暂时只有4个div，如果div的数量增加到100个，1000个，10000个，甚至1000000个呢？ 所以需要对上面的代码进行优化，优化的思路就是我们在上面提到的，首先创建一个处理函数，然后在循环中直接使用已经创建好的函数即可，这样内存中就只有一份函数代码存在了。 优化后的JavaScript代码 function divClick(){ this.firstChild.nodeValue = \"我被点击了\"; } var divs = document.getElementsByTagName(\"div\"); for(var i = 0; i "},"Sources/5.1_ECMAScript 6 简介.html":{"url":"Sources/5.1_ECMAScript 6 简介.html","title":"5.1 ECMAScript 6 简介","keywords":"","body":"什么是ES6？ 又叫es2015，es7是2016 ECMAScript es标准的作用： 定义js的发展方向的一套标准 ECMAScript ES es3 es5 严格模式 es6/es2015/ECMAScript 6.0 变量定义变化let const 块级作用域 解构赋值 字符串、函数、数组的扩展 新的面向对象编程语法 异步 ...... ES6狭义上就是指ES2015，广义上是一个泛指，指5.1版本以后的JavaScript的下一代标准，涵盖了ES2015,ES2016,ES2017等；亦指下一代JavaScript语言。 本书中提到 ES6 的地方，一般是指 ES2015 标准 Bable Bable：Babel是一个JavaScript编译器，它可以将ES6+语法编译为浏览器支持的ES5语法。 TypeScript (也是一个趋势，很火热) TypeScript是 JavaScript 的一个超集，支持 ECMAScript 6 标准。 TypeScript 是由微软开发的自由和开源的编程语言。 TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。 语言特性 TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括： 类型批注和编译时类型检查 类型推断 类型擦除 接口 枚举 Mixin 泛型编程 名字空间 元组 Await 以下功能是从 ECMA 2015 反向移植而来： 类 模块 lambda 函数的箭头语法 可选参数以及默认参数 JavaScript 与 TypeScript 的区别 TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。 TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。 ES5 ⊂ ES6 ⊂ TypeScript "},"Sources/5.2_let和const命令.html":{"url":"Sources/5.2_let和const命令.html","title":"5.2 let和const命令","keywords":"","body":"变量定义变化let/const let ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 不允许重复声明：let不允许在相同作用域内，重复声明同一个变量。 块级作用域：let 声明的变量，只在 let 命令所在的代码块内有效。解决命名冲突问题，能体现代码的封装性 let命令每次定义的作用域都在本次循环的方法体内，即每一次循环的i其实都是一个新的变量。 不存在变量提升：var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 暂时性死区：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 var tmp = 123; if (true) { tmp = 'abc'; // ReferenceError let tmp; } // 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 const const声明一个只读的常量。一旦声明，常量的值就不能改变。 const定义常量时，必须初始化，否则Missing initializer in const declaration 如定义了常量，再去修改就会报错error Assignment to constant variable 不可以给常量赋值 const定义的常量，作用域与let相同 应用场景：const用来定义静态变量，加载模块的时候，定义个常量，把模块赋值给常量 比较 var let const 重复定义 允许 不允许 不允许 作用域 不受块级作用域限制 块级作用域(只在声明所在的块级作用域内有效) 块级作用域 变量提升 是 否 否 值 可以改变 可以改变 不可以改 "},"Sources/5.3_块级作用域.html":{"url":"Sources/5.3_块级作用域.html","title":"5.3 块级作用域","keywords":"","body":"块级作用域 为什么需要块级作用域？ ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 var tmp = new Date(); function f() { console.log(tmp); if (false) { var tmp = 'hello world'; } } f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 var s = 'hello'; for (var i = 0; i 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 块级作用域 凡是被{}包裹的代码属于一个代码块。 ES6 允许块级作用域的任意嵌套。 \\{\\{\\{\\{ { let insane = 'Hello World' } console.log(insane); // 报错 }}}}; 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 // IIFE 写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } 块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。以下代码根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此下面两种情况实际都能运行，不会报错。 // 情况一 if (true) { function f() {} } // 情况二 try { function f() {} } catch(e) { // ... } ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 "},"Sources/5.4_解构赋值.html":{"url":"Sources/5.4_解构赋值.html","title":"5.4 解构赋值","keywords":"","body":"变量的解构赋值 注意：下面使用默认值的场景中，都是只有值严格等于 undefined 时才会触发默认值，等于 null 不会触发默认值 一、数据的解构赋值 1.1 基本用法 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 let a = 1; let b = 2; let c = 3; ES6 允许写成下面这样。 let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”(Swift语言特性、C#好像也有)，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 完全解构(如上) 不完全解构。即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 let [x, y] = [1, 2, 3]; x // 1 y // 2 let [a, [b], d] = [1, [2, 3], 4]; a // 1 b // 2 d // 4 解构不成功。变量的值会等于undefined let [x, y, ...z] = ['a']; x // \"a\" y // undefined z // [] let [foo] = []; //foo undefined let [bar, foo] = [1]; //foo undefined 解构报错。如果等号的右边不是数组（或者严格地说，不是可遍历的结构 — 要么转为对象以后不具备 Iterator 接口，要么本身就不具备 Iterator 接口），那么将会报错。 // 报错 let [foo] = 1; let [foo] = false; let [foo] = NaN; let [foo] = undefined; let [foo] = null; // 以上转为对象以后不具备 Iterator 接口 let [foo] = {}; // 以上本身就不具备 Iterator 接口 1.2 默认值 解构赋值允许指定默认值。 let [foo = true] = []; foo // true let [x, y = 'b'] = ['a']; // x='a', y='b' let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意： ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 let [x = 1] = [undefined]; x // 1 let [x = 1] = [null]; x // null 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 function f() { console.log('aaa'); } let [x = f()] = [1]; // 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 let x; if ([1][0] === undefined) { x = f(); } else { x = [1][0]; } 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 let [x = 1, y = x] = []; // x=1; y=1 let [x = 1, y = x] = [2]; // x=2; y=2 let [x = 1, y = x] = [1, 2]; // x=1; y=2 let [x = y, y = 1] = []; // ReferenceError: y is not defined 因为x用y做默认值时，y还没有声明。 二、对象的解构赋值 2.1 基本用法 解构不仅可以用于数组，还可以用于对象。 let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; foo // \"aaa\" bar // \"bbb\" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 如果解构失败，变量的值等于undefined。 如果变量名与属性名不一致，必须写成下面这样。 let { foo: baz } = { foo: 'aaa', bar: 'bbb' }; baz // \"aaa\" let obj = { first: 'hello', last: 'world' }; let { first: f, last: l } = obj; f // 'hello' l // 'world' 前者是匹配的模式，后者才是变量。真正被赋值的是后者-变量，而不是前者-模式。 2.2 默认值 对象的解构也可以指定默认值。 var {x = 3} = {}; x // 3 var {x, y = 5} = {x: 1}; x // 1 y // 5 var {x: y = 3} = {}; y // 3 var {x: y = 3} = {x: 5}; y // 5 var { message: msg = 'Something went wrong' } = {}; msg // \"Something went wrong\" 默认值生效的条件是，对象的属性值严格等于`undefined`。 var {x = 3} = {x: undefined}; x // 3 var {x = 3} = {x: null}; x // null 上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。 2.3 注意点 （1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。 // 错误的写法 let x; {x} = {x: 1}; // SyntaxError: syntax error 上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。 // 正确的写法 let x; ({x} = {x: 1}); 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 （2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 ({} = [true, false]); ({} = 'abc'); ({} = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 （3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 let arr = [1, 2, 3]; let {0 : first, [arr.length - 1] : last} = arr; first // 1 last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。 三、字符串的解构赋值 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 const [a, b, c, d, e] = 'hello'; a // \"h\" b // \"e\" c // \"l\" d // \"l\" e // \"o\" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 let {length : len} = 'hello'; len // 5 四、数值和布尔值的解构赋值 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 let {toString: s} = 123; s === Number.prototype.toString // true let {toString: s} = true; s === Boolean.prototype.toString // true // 上面代码中，数值和布尔值的包装对象都有`toString`属性，因此变量`s`都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 let { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError 五、函数参数的解构赋值 5.1 基本用法 函数的参数也可以使用解构赋值。 function add([x, y]){ return x + y; } add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 5.2 默认值 函数参数的解构也可以使用默认值。 function move({x = 0, y = 0}) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, 0] move({}); // [0, 0] move(); // TypeError: Cannot read property 'x' of undefined // 上面代码中，参数是一个对象，通过对这个对象进行解构，得到变量`x`和`y`的值。如果解构失败，`x`和`y`等于默认值。 上面的代码中，move函数只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数move的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数move调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值（称为函数参数默认值，这里简单说一下），就可以避免这种情况。 参数默认值可以与解构赋值的默认值，结合起来使用： function move({x = 0, y = 0} = {}) { return [x, y]; } move(); // [0, 0] 注意，下面的写法会得到不一样的结果。 function move({x, y} = { x: 0, y: 0 }) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, undefined] move({}); // [undefined, undefined] move(); // [0, 0] // 上面代码是为函数`move`的参数指定默认值，而不是为变量`x`和`y`指定默认值，所以会得到与前一种写法不同的结果。 `undefined`就会触发函数参数的默认值。 六、圆括号问题 解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 6.1 不能使用圆括号的情况 以下三种解构赋值不得使用圆括号。 （1）变量声明语句 // 全部报错 let [(a)] = [1]; let {x: (c)} = {}; let ({x: c}) = {}; let {(x: c)} = {}; let {(x): c} = {}; let { o: ({ p: p }) } = { o: { p: 2 } }; 上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数 函数参数也属于变量声明，因此不能带有圆括号。 // 报错 function f([(z)]) { return z; } // 报错 function f([z,(x)]) { return x; } （3）赋值语句的模式 // 全部报错 ({ p: a }) = { p: 42 }; ([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 // 报错 [({ p: a }), { x: c }] = [{}, {}]; 上面代码将一部分模式放在圆括号之中，导致报错。 6.2 可以使用圆括号的情况 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 [(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 "},"Sources/5.5_字符串的一些扩展.html":{"url":"Sources/5.5_字符串的一些扩展.html","title":"5.5 字符串的扩展","keywords":"","body":"字符串的一些扩展 模板字符串 传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 $('#result').append( 'There are ' + basket.count + ' ' + 'items in your basket, ' + '' + basket.onSale + ' are on sale!' ); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 $('#result').append(` There are ${basket.count} items in your basket, ${basket.onSale} are on sale! `); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。（原理：正则实现） 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 模板字符串是可以嵌套的 如果需要引用模板字符串本身，在需要时执行，可以写成函数。 let func = (name) => `Hello ${name}!`; func('Jack') // \"Hello Jack!\" 上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。 使用： 可以当作普通字符串使用 可以用来定义多行字符串 可以用来变量、字符串拼接。在模板字符串中嵌入变量，将变量名写在${}之中 大括号内部可以放入任意的 JavaScript 表达式、使用对象的属性、调用函数 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。 大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。 标签模板 模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数。 如果模板字符串中没有变量，那么紧跟在后面的模板字符串就是标签/函数的参数。 alert`hello` // 等同于 alert(['hello']) 如果模板字符串中有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 函数的第一个参数是一个数组，该数组的成员是模板字符串中，被${...}分割开的部分 其他参数，依次是模板字符串中各个变量被替换后的值。 let a = 5; let b = 10; tag`Hello ${ a + b } world ${ a * b }`; // 等同于 tag(['Hello ', ' world ', ''], 15, 50); // 3个参数 字符串新增方法 str.includes(str) //是否包含str这个字符串 str.startWith(str) //是否以str开头 str.endWith(str) //是否以str结尾 str.repeat(次数) //循环打印字符串 String.raw`hello world\\n` // 该方法往往用于模板字符串的处理，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。 // 你通常不需要把它看成一个普通函数，你只需要把它放在模板字符串前面就可以了，而不是在它后面加个括号和一堆参数来调用它，引擎会替你去调用它。 "},"Sources/5.6_函数、数组、OOP的扩展.html":{"url":"Sources/5.6_函数、数组、OOP的扩展.html","title":"5.6 函数、数组、OOP的扩展","keywords":"","body":"见源代码注释 "},"Sources/5.7_异步编程.html":{"url":"Sources/5.7_异步编程.html","title":"5.7 异步编程","keywords":"","body":"异步编程 同步：任务之间存在一定的约束关系，在执行过程中，存在一定的前后顺序 异步：可以解释为两(多)者之间在随时间的执行过程中，两者之间没有约束关系，相互独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。 各任务以其相对独立的不可预知的速度向前推进。 异步一般需要通过多进程、多线程来实现。 应用场景：延时任务、耗时任务。 需求：需要监听延时-时间到达、耗时任务完成，在此时做一些操作。 技术方案 技术方案：ES6 诞生以前，异步编程的方法，大概有下面四种。 回调函数：以函数作为参数。这个操作一般称为回调callback。 Callback是\"call back\"两个单字的合体，应该有听过\" Call me back\"的英文。电信公司中的说法大概是有客户打来电话给你，可是你正在电话中，客户会留话说请你等会有空时再\"回电\"给它。在程式开发上，callback的使用情境其实也类似—有空了/时间到了/任务执行完了，回过头来调用的。 事件监听 发布/订阅 ES6 Promise 对象 ES6 Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。 ES8 async+await 所有的技术 — 目标：使 异步任务完成后的 回调 更优雅。可读性更高。以同步的方式去写异步的代码 1. 回调函数 以函数作为参数，将此函数称为回调函数。而接收函数作为参数的函数也称为高阶函数。 缺点：可能造成回调地狱(Callback Hell)(多个任务之间相互依赖，回调函数一层层向下嵌套) 2. ES6 Promise对象 3. ES6 generator 4. ES8 async+await "},"Sources/5.8_发布订阅模式和观察者模式.html":{"url":"Sources/5.8_发布订阅模式和观察者模式.html","title":"5.8 发布订阅模式和观察者模式","keywords":"","body":"发布订阅和观察者模式 发布订阅模式、观察者模式是不一样的。 发布订阅模式 或许你用过 eventemitter、node 的 events、Backbone 的 events 等等，这些都是前端早期，比较流行的数据流通信方式，即订阅发布模式。 从字面意思来看，我们需要首先订阅，发布者发布消息后才会收到发布的消息。不过我们还需要一个中间者来协调，从事件角度来说，这个中间者就是事件中心，协调发布者和订阅者直接的消息通信。 完成订阅发布整个流程需要三个角色： 发布者 事件中心 订阅者 以事件为例，简单流程如下： 发布者->事件中心订阅者 订阅者需要向事件中心订阅指定的事件 -> 发布者向事件中心发布指定事件内容 -> 事件中心通知订阅者 -> 订阅者收到消息（可能是多个订阅者），到此完成了一次订阅发布的流程。 观察者模式 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 观察者模式我们可能比较熟悉的场景就是响应式数据，如 Vue 的响应式、Mbox 的响应式。 观察者模式有完成整个流程需要两个角色： 目标 观察者 简单流程如下： 目标观察者 观察者观察目标（监听目标）-> 目标发生变化-> 目标主动通知观察者 "},"Sources/5.9_模块化.html":{"url":"Sources/5.9_模块化.html","title":"5.9 模块化Module","keywords":"","body":"模块化 历史上，JavaScript 一直没有模块（module）体系。在 ES6 之前，社区制定了一些模块加载方案，最主要的有： 服务器规范 CommonJS => NodeJS、 Browserify 浏览器规范 AMD => requireJS 浏览器规范 CMD => seaJS ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 什么是模块化 模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。 现实中的模块化 生产效率高 维护方便，成本低 程序中的模块化 开发效率高 一次编写多次使用 方便维护（维护的成本更低）模块之间有高耦合低内聚的特点 模块化的好处 模块化的优势有以下几点: 防止命名冲突 代码复用 高维护性 ES6 模块化语法 模块功能主要由两个命令构成: export 和 import export 命令用于规定模块的对外接口 import 命令用于输入其他模块提供的功能 扩展 — CMD - SeaJS模块化语法 定义模块 define作用域就在define的函数体里，三个参数require、exports、module 加载模块 require 在一个模块系统中，require 加载过的模块会被缓存 默认 require 是同步加载模块的 暴露接口 exports 和 module.exports exports是module.exports的别名，exports能做什么，module.exports就能做什么 启动模块系统 seajs.use(callback) seajs.use 和 Document 的 ready 没有任何关系 要想保证 文档结构加载完毕再执行你的 js 代码，一定要在 seajs.use 内部通过 window.onload 或者 $(function(){}) 分清楚前台模块化和node中的模块化的区别 掌握模块化的思想 扩展 — Nodejs模块化(见后面Nodejs章节) "}}